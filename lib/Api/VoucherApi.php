<?php

/**
 * VoucherApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
/**
 * sevDesk
 *
 * # Getting started  The sevDesk API v1 uses a token authentication.    You need to click on the authorization button (lock symbol) and enter your api-key there.    The token can be found on [https://my.sevdesk.de](https://my.sevdesk.de).    settings-->user-->specific user    # General information    The sevDesk api uses **models** to represent the different categories like **contacts** and **invoices**.    Every time you request such a model from the api, it will return the whole model schema including the unique **model id** and all the other objects and parameters that are included in the model.    Have a look at it in the developer console of your desired browser, especially if you are looking for specific parameters like the model id.    # URL    The basic URL contains four elements. **BaseURL** + **Controller** + **Version** + **Model**: [https://my.sevdesk.de/api/v1/Contact/](https://my.sevdesk.de/api/v1/Contact/)    # Basic Operations    Access a list of models: [https://my.sevdesk.de/api/v1/{Model}/](https://my.sevdesk.de/api/v1/{Model}/)    Access a specific model: [https://my.sevdesk.de/api/v1/{Model}/{id}](https://my.sevdesk.de/api/v1/{Model}/{id})    The **id** of a specific model can usually be found in the **developer console** of your browser or when opening a specific model, in the **url**.    Call a model function: [https://my.sevdesk.de/api/v1/{Model}/{id}/{Function}](https://my.sevdesk.de/api/v1/{Model}/{id}/{Function})    Each operation can be used with different HTTP methods:  * GET - read data  * POST - create data  * PUT - update existing data  * DELETE - delete data    # Useful Parameters    For each request, there are some specific parameters.    **GET Query Parameters**  * **limit** - limits the number of entries returned  * **offset** - set the index where the returned entries should start  * **embed** - embed can be used to get some additional information about a model. For example you can get the addresses of a contact with **embed=addresses**    `[GET]https://my.sevdesk.de/api/v1/Contact/?embed=addresses`    * If there is a need to get more information about the country in the addresses, embed can be extended by **addresses.country**    `[GET]https://my.sevdesk.de/api/v1/Contact/?embed=addresses,addresses.country`    * Some models also contain other models. By default these models are only filled with an id and objectName. If you want to get more information about the nested model you can use embed too.    `[GET]https://my.sevdesk.de/api/v1/Contact/?embed=parent`    * Every model also has specified 'query parameters'. These can be used to filter the results. E.g. all Contacts with a 'Company' in their name    `[GET]https://my.sevdesk.de/api/v1/Contact/?name=Company`    * **countAll** If countAll is set to 1 the total number of entries will be returned additionally  * **orderBy** Is an array that can be filled with objects containing the the properties field and arrangement    `json: orderBy = [{field:'parent' ,arrangement:'desc'},{field:'name' ,arrangement:'asc'}];`    `url: ?orderBy[0][field]=parent&orderBy[0][arrangement]=desc&orderBy[1][field]=name&orderBy[1][arrangement]=asc`
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.4
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * VoucherApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class VoucherApi {

    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
            ClientInterface $client = null,
            Configuration $config = null,
            HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig() {
        return $this->config;
    }

    /**
     * Operation addVoucher
     *
     * Create a new voucher
     *
     * @param  string $body To create a voucher, simply enter desired values after parameter&#x3D; and remove the quotation marks.      Be aware that you can&#39;t use all the parameters included in the Model_Voucher, as creating a voucher involves other functions.      So for example, adding a sumNet/Gross/etc. does not work as they normally get their value from the product which is involved in the voucher      The product/part in this case is handled in the Model_VoucherPos which makes a call to Model_Part. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ModelVoucher
     */
    public function addVoucher($body) {
        list($response) = $this->addVoucherWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation addVoucherWithHttpInfo
     *
     * Create a new voucher
     *
     * @param  string $body To create a voucher, simply enter desired values after parameter&#x3D; and remove the quotation marks.      Be aware that you can&#39;t use all the parameters included in the Model_Voucher, as creating a voucher involves other functions.      So for example, adding a sumNet/Gross/etc. does not work as they normally get their value from the product which is involved in the voucher      The product/part in this case is handled in the Model_VoucherPos which makes a call to Model_Part. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ModelVoucher, HTTP status code, HTTP response headers (array of strings)
     */
    public function addVoucherWithHttpInfo($body) {
        $returnType = '\Swagger\Client\Model\ModelVoucher';
        $request = $this->addVoucherRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                        "[{$e->getCode()}] {$e->getMessage()}",
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                        sprintf(
                                '[%d] Error connecting to the API (%s)',
                                $statusCode,
                                $request->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                                    $e->getResponseBody(),
                                    '\Swagger\Client\Model\ModelVoucher',
                                    $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addVoucherAsync
     *
     * Create a new voucher
     *
     * @param  string $body To create a voucher, simply enter desired values after parameter&#x3D; and remove the quotation marks.      Be aware that you can&#39;t use all the parameters included in the Model_Voucher, as creating a voucher involves other functions.      So for example, adding a sumNet/Gross/etc. does not work as they normally get their value from the product which is involved in the voucher      The product/part in this case is handled in the Model_VoucherPos which makes a call to Model_Part. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addVoucherAsync($body) {
        return $this->addVoucherAsyncWithHttpInfo($body)
                        ->then(
                                function ($response) {
                            return $response[0];
                        }
        );
    }

    /**
     * Operation addVoucherAsyncWithHttpInfo
     *
     * Create a new voucher
     *
     * @param  string $body To create a voucher, simply enter desired values after parameter&#x3D; and remove the quotation marks.      Be aware that you can&#39;t use all the parameters included in the Model_Voucher, as creating a voucher involves other functions.      So for example, adding a sumNet/Gross/etc. does not work as they normally get their value from the product which is involved in the voucher      The product/part in this case is handled in the Model_VoucherPos which makes a call to Model_Part. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addVoucherAsyncWithHttpInfo($body) {
        $returnType = '\Swagger\Client\Model\ModelVoucher';
        $request = $this->addVoucherRequest($body);

        return $this->client
                        ->sendAsync($request, $this->createHttpClientOption())
                        ->then(
                                function ($response) use ($returnType) {
                            $responseBody = $response->getBody();
                            if ($returnType === '\SplFileObject') {
                                $content = $responseBody; //stream goes to serializer
                            } else {
                                $content = $responseBody->getContents();
                                if ($returnType !== 'string') {
                                    $content = json_decode($content);
                                }
                            }

                            return [
                                ObjectSerializer::deserialize($content, $returnType, []),
                                $response->getStatusCode(),
                                $response->getHeaders()
                            ];
                        },
                                function ($exception) {
                            $response = $exception->getResponse();
                            $statusCode = $response->getStatusCode();
                            throw new ApiException(
                                    sprintf(
                                            '[%d] Error connecting to the API (%s)',
                                            $statusCode,
                                            $exception->getRequest()->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $response->getBody()
                            );
                        }
        );
    }

    /**
     * Create request for operation 'addVoucher'
     *
     * @param  string $body To create a voucher, simply enter desired values after parameter&#x3D; and remove the quotation marks.      Be aware that you can&#39;t use all the parameters included in the Model_Voucher, as creating a voucher involves other functions.      So for example, adding a sumNet/Gross/etc. does not work as they normally get their value from the product which is involved in the voucher      The product/part in this case is handled in the Model_VoucherPos which makes a call to Model_Part. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addVoucherRequest($body) {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                    'Missing the required parameter $body when calling addVoucher'
            );
        }

        $resourcePath = '/Voucher';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                    ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                    ['application/xml', 'application/json'],
                    ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
                $defaultHeaders,
                $headerParams,
                $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
                'POST',
                $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
        );
    }

    /**
     * Operation deleteVoucher
     *
     * Delete an existing voucher
     *
     * @param  int $id Id of voucher you want to delete (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteVoucher($id) {
        $this->deleteVoucherWithHttpInfo($id);
    }

    /**
     * Operation deleteVoucherWithHttpInfo
     *
     * Delete an existing voucher
     *
     * @param  int $id Id of voucher you want to delete (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteVoucherWithHttpInfo($id) {
        $returnType = '';
        $request = $this->deleteVoucherRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                        "[{$e->getCode()}] {$e->getMessage()}",
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                        sprintf(
                                '[%d] Error connecting to the API (%s)',
                                $statusCode,
                                $request->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation deleteVoucherAsync
     *
     * Delete an existing voucher
     *
     * @param  int $id Id of voucher you want to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteVoucherAsync($id) {
        return $this->deleteVoucherAsyncWithHttpInfo($id)
                        ->then(
                                function ($response) {
                            return $response[0];
                        }
        );
    }

    /**
     * Operation deleteVoucherAsyncWithHttpInfo
     *
     * Delete an existing voucher
     *
     * @param  int $id Id of voucher you want to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteVoucherAsyncWithHttpInfo($id) {
        $returnType = '';
        $request = $this->deleteVoucherRequest($id);

        return $this->client
                        ->sendAsync($request, $this->createHttpClientOption())
                        ->then(
                                function ($response) use ($returnType) {
                            return [null, $response->getStatusCode(), $response->getHeaders()];
                        },
                                function ($exception) {
                            $response = $exception->getResponse();
                            $statusCode = $response->getStatusCode();
                            throw new ApiException(
                                    sprintf(
                                            '[%d] Error connecting to the API (%s)',
                                            $statusCode,
                                            $exception->getRequest()->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $response->getBody()
                            );
                        }
        );
    }

    /**
     * Create request for operation 'deleteVoucher'
     *
     * @param  int $id Id of voucher you want to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteVoucherRequest($id) {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                    'Missing the required parameter $id when calling deleteVoucher'
            );
        }

        $resourcePath = '/Voucher/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                    '{' . 'id' . '}',
                    ObjectSerializer::toPathValue($id),
                    $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                    ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                    ['application/xml', 'application/json'],
                    ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
                $defaultHeaders,
                $headerParams,
                $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
                'DELETE',
                $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
        );
    }

    /**
     * Operation getVouchers
     *
     * Get an overview of all vouchers
     *
     * @param  int $limit Limits the number of entries returned. Default is 100 (optional, default to 100)
     * @param  int $offset Set the index where the returned vouchers start. Default is 0 (optional, default to 0)
     * @param  string[] $embed Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ModelVoucher
     */
    public function getVouchers($id = null, $limit = '100', $offset = '0', $embed = null) {
        list($response) = $this->getVouchersWithHttpInfo($id, $limit, $offset, $embed);
        return $response;
    }

    /**
     * Operation getVouchersWithHttpInfo
     *
     * Get an overview of all vouchers
     *
     * @param  int $limit Limits the number of entries returned. Default is 100 (optional, default to 100)
     * @param  int $offset Set the index where the returned vouchers start. Default is 0 (optional, default to 0)
     * @param  string[] $embed Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ModelVoucher, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVouchersWithHttpInfo($id = null, $limit = '100', $offset = '0', $embed = null) {
        $returnType = '\Swagger\Client\Model\ModelVoucher';
        $request = $this->getVouchersRequest($id, $limit, $offset, $embed);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                        "[{$e->getCode()}] {$e->getMessage()}",
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                        sprintf(
                                '[%d] Error connecting to the API (%s)',
                                $statusCode,
                                $request->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content, true);
                }
            }

            return [
                $content['objects'],
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                                    $e->getResponseBody(),
                                    '\Swagger\Client\Model\ModelVoucher',
                                    $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVouchersAsync
     *
     * Get an overview of all vouchers
     *
     * @param  int $limit Limits the number of entries returned. Default is 100 (optional, default to 100)
     * @param  int $offset Set the index where the returned vouchers start. Default is 0 (optional, default to 0)
     * @param  string[] $embed Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVouchersAsync($limit = '100', $offset = '0', $embed = null) {
        return $this->getVouchersAsyncWithHttpInfo($limit, $offset, $embed)
                        ->then(
                                function ($response) {
                            return $response[0];
                        }
        );
    }

    /**
     * Operation getVouchersAsyncWithHttpInfo
     *
     * Get an overview of all vouchers
     *
     * @param  int $limit Limits the number of entries returned. Default is 100 (optional, default to 100)
     * @param  int $offset Set the index where the returned vouchers start. Default is 0 (optional, default to 0)
     * @param  string[] $embed Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVouchersAsyncWithHttpInfo($limit = '100', $offset = '0', $embed = null) {
        $returnType = '\Swagger\Client\Model\ModelVoucher';
        $request = $this->getVouchersRequest($limit, $offset, $embed);

        return $this->client
                        ->sendAsync($request, $this->createHttpClientOption())
                        ->then(
                                function ($response) use ($returnType) {
                            $responseBody = $response->getBody();
                            if ($returnType === '\SplFileObject') {
                                $content = $responseBody; //stream goes to serializer
                            } else {
                                $content = $responseBody->getContents();
                                if ($returnType !== 'string') {
                                    $content = json_decode($content);
                                }
                            }

                            return [
                                ObjectSerializer::deserialize($content, $returnType, []),
                                $response->getStatusCode(),
                                $response->getHeaders()
                            ];
                        },
                                function ($exception) {
                            $response = $exception->getResponse();
                            $statusCode = $response->getStatusCode();
                            throw new ApiException(
                                    sprintf(
                                            '[%d] Error connecting to the API (%s)',
                                            $statusCode,
                                            $exception->getRequest()->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $response->getBody()
                            );
                        }
        );
    }

    /**
     * Create request for operation 'getVouchers'
     *
     * @param  int $limit Limits the number of entries returned. Default is 100 (optional, default to 100)
     * @param  int $offset Set the index where the returned vouchers start. Default is 0 (optional, default to 0)
     * @param  string[] $embed Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVouchersRequest($id = null, $limit = '100', $offset = '0', $embed = null) {

        $resourcePath = '/Voucher';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id);
        } else {
            // query params
            if ($limit !== null) {
                $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
            }
            // query params
            if ($offset !== null) {
                $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
            }
        }
        // query params
        if (is_array($embed)) {
            $embed = ObjectSerializer::serializeCollection($embed, 'csv', true);
        }
        if ($embed !== null) {
            $queryParams['embed'] = ObjectSerializer::toQueryValue($embed);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                    ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                    ['application/xml', 'application/json'],
                    ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
                $defaultHeaders,
                $headerParams,
                $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
                'GET',
                $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
        );
    }

    /**
     * Operation saveVoucher
     *
     * Create a new voucher
     *
     * @param  string $body The saveVoucher function in Voucher/Factory.php combines both Voucher and VoucherPos with all their HTTP-methods.    It is now possible to **simultaneously** create a voucher with its position.    To simply (only) create a voucher you can use the given parameters and concatenate your values.    For also adding a voucher position refer to the **quick reference** below.    The parameters you find there are **needed** for creating a voucher position. Just concatenate them to the existing voucher parameters.    You can also find additional (optional) parameters in the **Models** section.    Quick reference:  * &amp;voucherPosSave[0][accountingType][id]&#x3D;  * &amp;voucherPosSave[0][accountingType][objectName]&#x3D;AccountingType  * &amp;voucherPosSave[0][taxRate]&#x3D;19  * &amp;voucherPosSave[0][sum]&#x3D;  * &amp;voucherPosSave[0][objectName]&#x3D;VoucherPos  * &amp;voucherPosSave[0][mapAll]&#x3D;true  * &amp;voucherPosDelete&#x3D;true/false &lt;-- if you provide this parameter, you can delete a voucher position    You can also use additional parameters for creating a voucher in the same way by adding them in the format: **voucher[yourParameter]** (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ModelVoucherFactory
     */
    public function saveVoucher($body) {
        list($response) = $this->saveVoucherWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation saveVoucherWithHttpInfo
     *
     * Create a new voucher
     *
     * @param  string $body The saveVoucher function in Voucher/Factory.php combines both Voucher and VoucherPos with all their HTTP-methods.    It is now possible to **simultaneously** create a voucher with its position.    To simply (only) create a voucher you can use the given parameters and concatenate your values.    For also adding a voucher position refer to the **quick reference** below.    The parameters you find there are **needed** for creating a voucher position. Just concatenate them to the existing voucher parameters.    You can also find additional (optional) parameters in the **Models** section.    Quick reference:  * &amp;voucherPosSave[0][accountingType][id]&#x3D;  * &amp;voucherPosSave[0][accountingType][objectName]&#x3D;AccountingType  * &amp;voucherPosSave[0][taxRate]&#x3D;19  * &amp;voucherPosSave[0][sum]&#x3D;  * &amp;voucherPosSave[0][objectName]&#x3D;VoucherPos  * &amp;voucherPosSave[0][mapAll]&#x3D;true  * &amp;voucherPosDelete&#x3D;true/false &lt;-- if you provide this parameter, you can delete a voucher position    You can also use additional parameters for creating a voucher in the same way by adding them in the format: **voucher[yourParameter]** (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ModelVoucherFactory, HTTP status code, HTTP response headers (array of strings)
     */
    public function saveVoucherWithHttpInfo($body) {
        $returnType = '\Swagger\Client\Model\ModelVoucherFactory';
        $request = $this->saveVoucherRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                        "[{$e->getCode()}] {$e->getMessage()}",
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                        sprintf(
                                '[%d] Error connecting to the API (%s)',
                                $statusCode,
                                $request->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                );
            }

            $responseBody = $response->getBody();

            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content, treu);
                }
            }

            return [
                $content,
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                                    $e->getResponseBody(),
                                    '\Swagger\Client\Model\ModelVoucherFactory',
                                    $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation saveVoucherAsync
     *
     * Create a new voucher
     *
     * @param  string $body The saveVoucher function in Voucher/Factory.php combines both Voucher and VoucherPos with all their HTTP-methods.    It is now possible to **simultaneously** create a voucher with its position.    To simply (only) create a voucher you can use the given parameters and concatenate your values.    For also adding a voucher position refer to the **quick reference** below.    The parameters you find there are **needed** for creating a voucher position. Just concatenate them to the existing voucher parameters.    You can also find additional (optional) parameters in the **Models** section.    Quick reference:  * &amp;voucherPosSave[0][accountingType][id]&#x3D;  * &amp;voucherPosSave[0][accountingType][objectName]&#x3D;AccountingType  * &amp;voucherPosSave[0][taxRate]&#x3D;19  * &amp;voucherPosSave[0][sum]&#x3D;  * &amp;voucherPosSave[0][objectName]&#x3D;VoucherPos  * &amp;voucherPosSave[0][mapAll]&#x3D;true  * &amp;voucherPosDelete&#x3D;true/false &lt;-- if you provide this parameter, you can delete a voucher position    You can also use additional parameters for creating a voucher in the same way by adding them in the format: **voucher[yourParameter]** (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveVoucherAsync($body) {
        return $this->saveVoucherAsyncWithHttpInfo($body)
                        ->then(
                                function ($response) {
                            return $response[0];
                        }
        );
    }

    /**
     * Operation saveVoucherAsyncWithHttpInfo
     *
     * Create a new voucher
     *
     * @param  string $body The saveVoucher function in Voucher/Factory.php combines both Voucher and VoucherPos with all their HTTP-methods.    It is now possible to **simultaneously** create a voucher with its position.    To simply (only) create a voucher you can use the given parameters and concatenate your values.    For also adding a voucher position refer to the **quick reference** below.    The parameters you find there are **needed** for creating a voucher position. Just concatenate them to the existing voucher parameters.    You can also find additional (optional) parameters in the **Models** section.    Quick reference:  * &amp;voucherPosSave[0][accountingType][id]&#x3D;  * &amp;voucherPosSave[0][accountingType][objectName]&#x3D;AccountingType  * &amp;voucherPosSave[0][taxRate]&#x3D;19  * &amp;voucherPosSave[0][sum]&#x3D;  * &amp;voucherPosSave[0][objectName]&#x3D;VoucherPos  * &amp;voucherPosSave[0][mapAll]&#x3D;true  * &amp;voucherPosDelete&#x3D;true/false &lt;-- if you provide this parameter, you can delete a voucher position    You can also use additional parameters for creating a voucher in the same way by adding them in the format: **voucher[yourParameter]** (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveVoucherAsyncWithHttpInfo($body) {
        $returnType = '\Swagger\Client\Model\ModelVoucherFactory';
        $request = $this->saveVoucherRequest($body);

        return $this->client
                        ->sendAsync($request, $this->createHttpClientOption())
                        ->then(
                                function ($response) use ($returnType) {
                            $responseBody = $response->getBody();
                            if ($returnType === '\SplFileObject') {
                                $content = $responseBody; //stream goes to serializer
                            } else {
                                $content = $responseBody->getContents();
                                if ($returnType !== 'string') {
                                    $content = json_decode($content);
                                }
                            }

                            return [
                                ObjectSerializer::deserialize($content, $returnType, []),
                                $response->getStatusCode(),
                                $response->getHeaders()
                            ];
                        },
                                function ($exception) {
                            $response = $exception->getResponse();
                            $statusCode = $response->getStatusCode();
                            throw new ApiException(
                                    sprintf(
                                            '[%d] Error connecting to the API (%s)',
                                            $statusCode,
                                            $exception->getRequest()->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $response->getBody()
                            );
                        }
        );
    }

    /**
     * Create request for operation 'saveVoucher'
     *
     * @param  string $body The saveVoucher function in Voucher/Factory.php combines both Voucher and VoucherPos with all their HTTP-methods.    It is now possible to **simultaneously** create a voucher with its position.    To simply (only) create a voucher you can use the given parameters and concatenate your values.    For also adding a voucher position refer to the **quick reference** below.    The parameters you find there are **needed** for creating a voucher position. Just concatenate them to the existing voucher parameters.    You can also find additional (optional) parameters in the **Models** section.    Quick reference:  * &amp;voucherPosSave[0][accountingType][id]&#x3D;  * &amp;voucherPosSave[0][accountingType][objectName]&#x3D;AccountingType  * &amp;voucherPosSave[0][taxRate]&#x3D;19  * &amp;voucherPosSave[0][sum]&#x3D;  * &amp;voucherPosSave[0][objectName]&#x3D;VoucherPos  * &amp;voucherPosSave[0][mapAll]&#x3D;true  * &amp;voucherPosDelete&#x3D;true/false &lt;-- if you provide this parameter, you can delete a voucher position    You can also use additional parameters for creating a voucher in the same way by adding them in the format: **voucher[yourParameter]** (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function saveVoucherRequest($body) {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                    'Missing the required parameter $body when calling saveVoucher'
            );
        }

        $resourcePath = '/Voucher/Factory/saveVoucher';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                    ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                    ['application/xml', 'application/json'],
                    ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
                $defaultHeaders,
                $headerParams,
                $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
                'POST',
                $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
        );
    }

    /**
     * Operation updateVoucher
     *
     * Update an existing voucher
     *
     * @param  int $id Id of the voucher you want to update (required)
     * @param  string $body Parameters which need to be updated. Please refer to the description from create invoice.      Enter the parameters according to the syntax: parameter1&#x3D;&amp;parameter2&#x3D; and remove the quotation marks (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ModelVoucher
     */
    public function updateVoucher($id, $body = null) {
        list($response) = $this->updateVoucherWithHttpInfo($id, $body);
        return $response;
    }

    /**
     * Operation updateVoucherWithHttpInfo
     *
     * Update an existing voucher
     *
     * @param  int $id Id of the voucher you want to update (required)
     * @param  string $body Parameters which need to be updated. Please refer to the description from create invoice.      Enter the parameters according to the syntax: parameter1&#x3D;&amp;parameter2&#x3D; and remove the quotation marks (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ModelVoucher, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateVoucherWithHttpInfo($id, $body = null) {
        $returnType = '\Swagger\Client\Model\ModelVoucher';
        $request = $this->updateVoucherRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                        "[{$e->getCode()}] {$e->getMessage()}",
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                        sprintf(
                                '[%d] Error connecting to the API (%s)',
                                $statusCode,
                                $request->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                                    $e->getResponseBody(),
                                    '\Swagger\Client\Model\ModelVoucher',
                                    $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateVoucherAsync
     *
     * Update an existing voucher
     *
     * @param  int $id Id of the voucher you want to update (required)
     * @param  string $body Parameters which need to be updated. Please refer to the description from create invoice.      Enter the parameters according to the syntax: parameter1&#x3D;&amp;parameter2&#x3D; and remove the quotation marks (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateVoucherAsync($id, $body = null) {
        return $this->updateVoucherAsyncWithHttpInfo($id, $body)
                        ->then(
                                function ($response) {
                            return $response[0];
                        }
        );
    }

    /**
     * Operation updateVoucherAsyncWithHttpInfo
     *
     * Update an existing voucher
     *
     * @param  int $id Id of the voucher you want to update (required)
     * @param  string $body Parameters which need to be updated. Please refer to the description from create invoice.      Enter the parameters according to the syntax: parameter1&#x3D;&amp;parameter2&#x3D; and remove the quotation marks (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateVoucherAsyncWithHttpInfo($id, $body = null) {
        $returnType = '\Swagger\Client\Model\ModelVoucher';
        $request = $this->updateVoucherRequest($id, $body);

        return $this->client
                        ->sendAsync($request, $this->createHttpClientOption())
                        ->then(
                                function ($response) use ($returnType) {
                            $responseBody = $response->getBody();
                            if ($returnType === '\SplFileObject') {
                                $content = $responseBody; //stream goes to serializer
                            } else {
                                $content = $responseBody->getContents();
                                if ($returnType !== 'string') {
                                    $content = json_decode($content);
                                }
                            }

                            return [
                                ObjectSerializer::deserialize($content, $returnType, []),
                                $response->getStatusCode(),
                                $response->getHeaders()
                            ];
                        },
                                function ($exception) {
                            $response = $exception->getResponse();
                            $statusCode = $response->getStatusCode();
                            throw new ApiException(
                                    sprintf(
                                            '[%d] Error connecting to the API (%s)',
                                            $statusCode,
                                            $exception->getRequest()->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $response->getBody()
                            );
                        }
        );
    }

    /**
     * Create request for operation 'updateVoucher'
     *
     * @param  int $id Id of the voucher you want to update (required)
     * @param  string $body Parameters which need to be updated. Please refer to the description from create invoice.      Enter the parameters according to the syntax: parameter1&#x3D;&amp;parameter2&#x3D; and remove the quotation marks (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateVoucherRequest($id, $body = null) {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                    'Missing the required parameter $id when calling updateVoucher'
            );
        }

        $resourcePath = '/Voucher/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                    '{' . 'id' . '}',
                    ObjectSerializer::toPathValue($id),
                    $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                    ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                    ['application/xml', 'application/json'],
                    ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
                $defaultHeaders,
                $headerParams,
                $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
                'PUT',
                $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
        );
    }

    /**
     * Operation voucherBookAmount
     *
     * Book an amount for a specified voucher
     *
     * @param  int $id Id of the voucher for which you want to book an amount (required)
     * @param  string $body To book an amount for your voucher, simply enter desired values after parameter&#x3D; and remove the quotation marks. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function voucherBookAmount($id, $body = null) {
        $this->voucherBookAmountWithHttpInfo($id, $body);
    }

    /**
     * Operation voucherBookAmountWithHttpInfo
     *
     * Book an amount for a specified voucher
     *
     * @param  int $id Id of the voucher for which you want to book an amount (required)
     * @param  string $body To book an amount for your voucher, simply enter desired values after parameter&#x3D; and remove the quotation marks. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function voucherBookAmountWithHttpInfo($id, $body = null) {
        $returnType = '';
        $request = $this->voucherBookAmountRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                        "[{$e->getCode()}] {$e->getMessage()}",
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                        sprintf(
                                '[%d] Error connecting to the API (%s)',
                                $statusCode,
                                $request->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation voucherBookAmountAsync
     *
     * Book an amount for a specified voucher
     *
     * @param  int $id Id of the voucher for which you want to book an amount (required)
     * @param  string $body To book an amount for your voucher, simply enter desired values after parameter&#x3D; and remove the quotation marks. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voucherBookAmountAsync($id, $body = null) {
        return $this->voucherBookAmountAsyncWithHttpInfo($id, $body)
                        ->then(
                                function ($response) {
                            return $response[0];
                        }
        );
    }

    /**
     * Operation voucherBookAmountAsyncWithHttpInfo
     *
     * Book an amount for a specified voucher
     *
     * @param  int $id Id of the voucher for which you want to book an amount (required)
     * @param  string $body To book an amount for your voucher, simply enter desired values after parameter&#x3D; and remove the quotation marks. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voucherBookAmountAsyncWithHttpInfo($id, $body = null) {
        $returnType = '';
        $request = $this->voucherBookAmountRequest($id, $body);

        return $this->client
                        ->sendAsync($request, $this->createHttpClientOption())
                        ->then(
                                function ($response) use ($returnType) {
                            return [null, $response->getStatusCode(), $response->getHeaders()];
                        },
                                function ($exception) {
                            $response = $exception->getResponse();
                            $statusCode = $response->getStatusCode();
                            throw new ApiException(
                                    sprintf(
                                            '[%d] Error connecting to the API (%s)',
                                            $statusCode,
                                            $exception->getRequest()->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $response->getBody()
                            );
                        }
        );
    }

    /**
     * Create request for operation 'voucherBookAmount'
     *
     * @param  int $id Id of the voucher for which you want to book an amount (required)
     * @param  string $body To book an amount for your voucher, simply enter desired values after parameter&#x3D; and remove the quotation marks. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function voucherBookAmountRequest($id, $body = null) {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                    'Missing the required parameter $id when calling voucherBookAmount'
            );
        }

        $resourcePath = '/Voucher/{id}/bookAmmount';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                    '{' . 'id' . '}',
                    ObjectSerializer::toPathValue($id),
                    $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                    ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                    ['application/xml', 'application/json'],
                    ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
                $defaultHeaders,
                $headerParams,
                $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
                'PUT',
                $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
        );
    }

    /**
     * Operation voucherChangeStatus
     *
     * Change status of a specified voucher
     *
     * @param  int $id Id of the voucher of which you want to change the status (required)
     * @param  string $body To change the status of your voucher, simply enter desired values after parameter&#x3D; and remove the quotation marks. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function voucherChangeStatus($id, $body = null) {
        $this->voucherChangeStatusWithHttpInfo($id, $body);
    }

    /**
     * Operation voucherChangeStatusWithHttpInfo
     *
     * Change status of a specified voucher
     *
     * @param  int $id Id of the voucher of which you want to change the status (required)
     * @param  string $body To change the status of your voucher, simply enter desired values after parameter&#x3D; and remove the quotation marks. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function voucherChangeStatusWithHttpInfo($id, $body = null) {
        $returnType = '';
        $request = $this->voucherChangeStatusRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                        "[{$e->getCode()}] {$e->getMessage()}",
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                        sprintf(
                                '[%d] Error connecting to the API (%s)',
                                $statusCode,
                                $request->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation voucherChangeStatusAsync
     *
     * Change status of a specified voucher
     *
     * @param  int $id Id of the voucher of which you want to change the status (required)
     * @param  string $body To change the status of your voucher, simply enter desired values after parameter&#x3D; and remove the quotation marks. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voucherChangeStatusAsync($id, $body = null) {
        return $this->voucherChangeStatusAsyncWithHttpInfo($id, $body)
                        ->then(
                                function ($response) {
                            return $response[0];
                        }
        );
    }

    /**
     * Operation voucherChangeStatusAsyncWithHttpInfo
     *
     * Change status of a specified voucher
     *
     * @param  int $id Id of the voucher of which you want to change the status (required)
     * @param  string $body To change the status of your voucher, simply enter desired values after parameter&#x3D; and remove the quotation marks. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voucherChangeStatusAsyncWithHttpInfo($id, $body = null) {
        $returnType = '';
        $request = $this->voucherChangeStatusRequest($id, $body);

        return $this->client
                        ->sendAsync($request, $this->createHttpClientOption())
                        ->then(
                                function ($response) use ($returnType) {
                            return [null, $response->getStatusCode(), $response->getHeaders()];
                        },
                                function ($exception) {
                            $response = $exception->getResponse();
                            $statusCode = $response->getStatusCode();
                            throw new ApiException(
                                    sprintf(
                                            '[%d] Error connecting to the API (%s)',
                                            $statusCode,
                                            $exception->getRequest()->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $response->getBody()
                            );
                        }
        );
    }

    /**
     * Create request for operation 'voucherChangeStatus'
     *
     * @param  int $id Id of the voucher of which you want to change the status (required)
     * @param  string $body To change the status of your voucher, simply enter desired values after parameter&#x3D; and remove the quotation marks. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function voucherChangeStatusRequest($id, $body = null) {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                    'Missing the required parameter $id when calling voucherChangeStatus'
            );
        }

        $resourcePath = '/Voucher/{id}/changeStatus';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                    '{' . 'id' . '}',
                    ObjectSerializer::toPathValue($id),
                    $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                    ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                    ['application/xml', 'application/json'],
                    ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
                $defaultHeaders,
                $headerParams,
                $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
                'PUT',
                $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
        );
    }

    /**
     * Operation voucherDeleteDocument
     *
     * Delete the document of an existing voucher
     *
     * @param  int $id Id of the voucher of which you want to delete the document (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function voucherDeleteDocument($id) {
        $this->voucherDeleteDocumentWithHttpInfo($id);
    }

    /**
     * Operation voucherDeleteDocumentWithHttpInfo
     *
     * Delete the document of an existing voucher
     *
     * @param  int $id Id of the voucher of which you want to delete the document (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function voucherDeleteDocumentWithHttpInfo($id) {
        $returnType = '';
        $request = $this->voucherDeleteDocumentRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                        "[{$e->getCode()}] {$e->getMessage()}",
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                        sprintf(
                                '[%d] Error connecting to the API (%s)',
                                $statusCode,
                                $request->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation voucherDeleteDocumentAsync
     *
     * Delete the document of an existing voucher
     *
     * @param  int $id Id of the voucher of which you want to delete the document (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voucherDeleteDocumentAsync($id) {
        return $this->voucherDeleteDocumentAsyncWithHttpInfo($id)
                        ->then(
                                function ($response) {
                            return $response[0];
                        }
        );
    }

    /**
     * Operation voucherDeleteDocumentAsyncWithHttpInfo
     *
     * Delete the document of an existing voucher
     *
     * @param  int $id Id of the voucher of which you want to delete the document (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voucherDeleteDocumentAsyncWithHttpInfo($id) {
        $returnType = '';
        $request = $this->voucherDeleteDocumentRequest($id);

        return $this->client
                        ->sendAsync($request, $this->createHttpClientOption())
                        ->then(
                                function ($response) use ($returnType) {
                            return [null, $response->getStatusCode(), $response->getHeaders()];
                        },
                                function ($exception) {
                            $response = $exception->getResponse();
                            $statusCode = $response->getStatusCode();
                            throw new ApiException(
                                    sprintf(
                                            '[%d] Error connecting to the API (%s)',
                                            $statusCode,
                                            $exception->getRequest()->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $response->getBody()
                            );
                        }
        );
    }

    /**
     * Create request for operation 'voucherDeleteDocument'
     *
     * @param  int $id Id of the voucher of which you want to delete the document (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function voucherDeleteDocumentRequest($id) {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                    'Missing the required parameter $id when calling voucherDeleteDocument'
            );
        }

        $resourcePath = '/Voucher/{id}/deleteDocument';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                    '{' . 'id' . '}',
                    ObjectSerializer::toPathValue($id),
                    $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                    ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                    ['application/xml', 'application/json'],
                    ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
                $defaultHeaders,
                $headerParams,
                $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
                'DELETE',
                $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
        );
    }

    /**
     * Operation voucherExtractThumb
     *
     * Extract file thumb
     *
     * @param  string $file_name Name of the file of which you want to extract the thumb (optional, default to )
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function voucherExtractThumb($file_name = '') {
        $this->voucherExtractThumbWithHttpInfo($file_name);
    }

    /**
     * Operation voucherExtractThumbWithHttpInfo
     *
     * Extract file thumb
     *
     * @param  string $file_name Name of the file of which you want to extract the thumb (optional, default to )
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function voucherExtractThumbWithHttpInfo($file_name = '') {
        $returnType = '';
        $request = $this->voucherExtractThumbRequest($file_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                        "[{$e->getCode()}] {$e->getMessage()}",
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                        sprintf(
                                '[%d] Error connecting to the API (%s)',
                                $statusCode,
                                $request->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation voucherExtractThumbAsync
     *
     * Extract file thumb
     *
     * @param  string $file_name Name of the file of which you want to extract the thumb (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voucherExtractThumbAsync($file_name = '') {
        return $this->voucherExtractThumbAsyncWithHttpInfo($file_name)
                        ->then(
                                function ($response) {
                            return $response[0];
                        }
        );
    }

    /**
     * Operation voucherExtractThumbAsyncWithHttpInfo
     *
     * Extract file thumb
     *
     * @param  string $file_name Name of the file of which you want to extract the thumb (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voucherExtractThumbAsyncWithHttpInfo($file_name = '') {
        $returnType = '';
        $request = $this->voucherExtractThumbRequest($file_name);

        return $this->client
                        ->sendAsync($request, $this->createHttpClientOption())
                        ->then(
                                function ($response) use ($returnType) {
                            return [null, $response->getStatusCode(), $response->getHeaders()];
                        },
                                function ($exception) {
                            $response = $exception->getResponse();
                            $statusCode = $response->getStatusCode();
                            throw new ApiException(
                                    sprintf(
                                            '[%d] Error connecting to the API (%s)',
                                            $statusCode,
                                            $exception->getRequest()->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $response->getBody()
                            );
                        }
        );
    }

    /**
     * Create request for operation 'voucherExtractThumb'
     *
     * @param  string $file_name Name of the file of which you want to extract the thumb (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function voucherExtractThumbRequest($file_name = '') {

        $resourcePath = '/Voucher/Factory/extractThumb';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($file_name !== null) {
            $queryParams['fileName'] = ObjectSerializer::toQueryValue($file_name);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                    ['application/pdf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                    ['application/pdf'],
                    ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
                $defaultHeaders,
                $headerParams,
                $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
                'GET',
                $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
        );
    }

    /**
     * Operation voucherGetAccountingTypes
     *
     * Get the accounting types of a specified voucher
     *
     * @param  int $id Id of the voucher of which you want to get the accounting types (required)
     * @param  string[] $embed Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ModelAccountingType
     */
    public function voucherGetAccountingTypes($id, $embed = null) {
        list($response) = $this->voucherGetAccountingTypesWithHttpInfo($id, $embed);
        return $response;
    }

    /**
     * Operation voucherGetAccountingTypesWithHttpInfo
     *
     * Get the accounting types of a specified voucher
     *
     * @param  int $id Id of the voucher of which you want to get the accounting types (required)
     * @param  string[] $embed Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ModelAccountingType, HTTP status code, HTTP response headers (array of strings)
     */
    public function voucherGetAccountingTypesWithHttpInfo($id, $embed = null) {
        $returnType = '\Swagger\Client\Model\ModelAccountingType';
        $request = $this->voucherGetAccountingTypesRequest($id, $embed);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                        "[{$e->getCode()}] {$e->getMessage()}",
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                        sprintf(
                                '[%d] Error connecting to the API (%s)',
                                $statusCode,
                                $request->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                                    $e->getResponseBody(),
                                    '\Swagger\Client\Model\ModelAccountingType',
                                    $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation voucherGetAccountingTypesAsync
     *
     * Get the accounting types of a specified voucher
     *
     * @param  int $id Id of the voucher of which you want to get the accounting types (required)
     * @param  string[] $embed Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voucherGetAccountingTypesAsync($id, $embed = null) {
        return $this->voucherGetAccountingTypesAsyncWithHttpInfo($id, $embed)
                        ->then(
                                function ($response) {
                            return $response[0];
                        }
        );
    }

    /**
     * Operation voucherGetAccountingTypesAsyncWithHttpInfo
     *
     * Get the accounting types of a specified voucher
     *
     * @param  int $id Id of the voucher of which you want to get the accounting types (required)
     * @param  string[] $embed Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voucherGetAccountingTypesAsyncWithHttpInfo($id, $embed = null) {
        $returnType = '\Swagger\Client\Model\ModelAccountingType';
        $request = $this->voucherGetAccountingTypesRequest($id, $embed);

        return $this->client
                        ->sendAsync($request, $this->createHttpClientOption())
                        ->then(
                                function ($response) use ($returnType) {
                            $responseBody = $response->getBody();
                            if ($returnType === '\SplFileObject') {
                                $content = $responseBody; //stream goes to serializer
                            } else {
                                $content = $responseBody->getContents();
                                if ($returnType !== 'string') {
                                    $content = json_decode($content);
                                }
                            }

                            return [
                                ObjectSerializer::deserialize($content, $returnType, []),
                                $response->getStatusCode(),
                                $response->getHeaders()
                            ];
                        },
                                function ($exception) {
                            $response = $exception->getResponse();
                            $statusCode = $response->getStatusCode();
                            throw new ApiException(
                                    sprintf(
                                            '[%d] Error connecting to the API (%s)',
                                            $statusCode,
                                            $exception->getRequest()->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $response->getBody()
                            );
                        }
        );
    }

    /**
     * Create request for operation 'voucherGetAccountingTypes'
     *
     * @param  int $id Id of the voucher of which you want to get the accounting types (required)
     * @param  string[] $embed Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function voucherGetAccountingTypesRequest($id, $embed = null) {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                    'Missing the required parameter $id when calling voucherGetAccountingTypes'
            );
        }

        $resourcePath = '/Voucher/{id}/getAccountingTypes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($embed)) {
            $embed = ObjectSerializer::serializeCollection($embed, 'csv', true);
        }
        if ($embed !== null) {
            $queryParams['embed'] = ObjectSerializer::toQueryValue($embed);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                    '{' . 'id' . '}',
                    ObjectSerializer::toPathValue($id),
                    $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                    ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                    ['application/xml', 'application/json'],
                    ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
                $defaultHeaders,
                $headerParams,
                $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
                'GET',
                $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
        );
    }

    /**
     * Operation voucherGetCheckAccountTransactionLogs
     *
     * Get the check account transaction logs of a specified voucher
     *
     * @param  int $id Id of the voucher of which you want to get the check account transaction logs (required)
     * @param  string[] $embed Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function voucherGetCheckAccountTransactionLogs($id, $embed = null) {
        $this->voucherGetCheckAccountTransactionLogsWithHttpInfo($id, $embed);
    }

    /**
     * Operation voucherGetCheckAccountTransactionLogsWithHttpInfo
     *
     * Get the check account transaction logs of a specified voucher
     *
     * @param  int $id Id of the voucher of which you want to get the check account transaction logs (required)
     * @param  string[] $embed Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function voucherGetCheckAccountTransactionLogsWithHttpInfo($id, $embed = null) {
        $returnType = '';
        $request = $this->voucherGetCheckAccountTransactionLogsRequest($id, $embed);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                        "[{$e->getCode()}] {$e->getMessage()}",
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                        sprintf(
                                '[%d] Error connecting to the API (%s)',
                                $statusCode,
                                $request->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation voucherGetCheckAccountTransactionLogsAsync
     *
     * Get the check account transaction logs of a specified voucher
     *
     * @param  int $id Id of the voucher of which you want to get the check account transaction logs (required)
     * @param  string[] $embed Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voucherGetCheckAccountTransactionLogsAsync($id, $embed = null) {
        return $this->voucherGetCheckAccountTransactionLogsAsyncWithHttpInfo($id, $embed)
                        ->then(
                                function ($response) {
                            return $response[0];
                        }
        );
    }

    /**
     * Operation voucherGetCheckAccountTransactionLogsAsyncWithHttpInfo
     *
     * Get the check account transaction logs of a specified voucher
     *
     * @param  int $id Id of the voucher of which you want to get the check account transaction logs (required)
     * @param  string[] $embed Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voucherGetCheckAccountTransactionLogsAsyncWithHttpInfo($id, $embed = null) {
        $returnType = '';
        $request = $this->voucherGetCheckAccountTransactionLogsRequest($id, $embed);

        return $this->client
                        ->sendAsync($request, $this->createHttpClientOption())
                        ->then(
                                function ($response) use ($returnType) {
                            return [null, $response->getStatusCode(), $response->getHeaders()];
                        },
                                function ($exception) {
                            $response = $exception->getResponse();
                            $statusCode = $response->getStatusCode();
                            throw new ApiException(
                                    sprintf(
                                            '[%d] Error connecting to the API (%s)',
                                            $statusCode,
                                            $exception->getRequest()->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $response->getBody()
                            );
                        }
        );
    }

    /**
     * Create request for operation 'voucherGetCheckAccountTransactionLogs'
     *
     * @param  int $id Id of the voucher of which you want to get the check account transaction logs (required)
     * @param  string[] $embed Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function voucherGetCheckAccountTransactionLogsRequest($id, $embed = null) {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                    'Missing the required parameter $id when calling voucherGetCheckAccountTransactionLogs'
            );
        }

        $resourcePath = '/Voucher/{id}/getCheckAccountTransactionLogs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($embed)) {
            $embed = ObjectSerializer::serializeCollection($embed, 'csv', true);
        }
        if ($embed !== null) {
            $queryParams['embed'] = ObjectSerializer::toQueryValue($embed);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                    '{' . 'id' . '}',
                    ObjectSerializer::toPathValue($id),
                    $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                    ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                    ['application/xml', 'application/json'],
                    ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
                $defaultHeaders,
                $headerParams,
                $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
                'GET',
                $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
        );
    }

    /**
     * Operation voucherGetCheckAccountTransactions
     *
     * Get the check account transactions of a specified voucher
     *
     * @param  int $id Id of the voucher of which you want to get the check account transactions (required)
     * @param  string[] $embed Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function voucherGetCheckAccountTransactions($id, $embed = null) {
        $this->voucherGetCheckAccountTransactionsWithHttpInfo($id, $embed);
    }

    /**
     * Operation voucherGetCheckAccountTransactionsWithHttpInfo
     *
     * Get the check account transactions of a specified voucher
     *
     * @param  int $id Id of the voucher of which you want to get the check account transactions (required)
     * @param  string[] $embed Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function voucherGetCheckAccountTransactionsWithHttpInfo($id, $embed = null) {
        $returnType = '';
        $request = $this->voucherGetCheckAccountTransactionsRequest($id, $embed);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                        "[{$e->getCode()}] {$e->getMessage()}",
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                        sprintf(
                                '[%d] Error connecting to the API (%s)',
                                $statusCode,
                                $request->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation voucherGetCheckAccountTransactionsAsync
     *
     * Get the check account transactions of a specified voucher
     *
     * @param  int $id Id of the voucher of which you want to get the check account transactions (required)
     * @param  string[] $embed Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voucherGetCheckAccountTransactionsAsync($id, $embed = null) {
        return $this->voucherGetCheckAccountTransactionsAsyncWithHttpInfo($id, $embed)
                        ->then(
                                function ($response) {
                            return $response[0];
                        }
        );
    }

    /**
     * Operation voucherGetCheckAccountTransactionsAsyncWithHttpInfo
     *
     * Get the check account transactions of a specified voucher
     *
     * @param  int $id Id of the voucher of which you want to get the check account transactions (required)
     * @param  string[] $embed Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voucherGetCheckAccountTransactionsAsyncWithHttpInfo($id, $embed = null) {
        $returnType = '';
        $request = $this->voucherGetCheckAccountTransactionsRequest($id, $embed);

        return $this->client
                        ->sendAsync($request, $this->createHttpClientOption())
                        ->then(
                                function ($response) use ($returnType) {
                            return [null, $response->getStatusCode(), $response->getHeaders()];
                        },
                                function ($exception) {
                            $response = $exception->getResponse();
                            $statusCode = $response->getStatusCode();
                            throw new ApiException(
                                    sprintf(
                                            '[%d] Error connecting to the API (%s)',
                                            $statusCode,
                                            $exception->getRequest()->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $response->getBody()
                            );
                        }
        );
    }

    /**
     * Create request for operation 'voucherGetCheckAccountTransactions'
     *
     * @param  int $id Id of the voucher of which you want to get the check account transactions (required)
     * @param  string[] $embed Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function voucherGetCheckAccountTransactionsRequest($id, $embed = null) {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                    'Missing the required parameter $id when calling voucherGetCheckAccountTransactions'
            );
        }

        $resourcePath = '/Voucher/{id}/getCheckAccountTransactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($embed)) {
            $embed = ObjectSerializer::serializeCollection($embed, 'csv', true);
        }
        if ($embed !== null) {
            $queryParams['embed'] = ObjectSerializer::toQueryValue($embed);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                    '{' . 'id' . '}',
                    ObjectSerializer::toPathValue($id),
                    $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                    ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                    ['application/xml', 'application/json'],
                    ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
                $defaultHeaders,
                $headerParams,
                $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
                'GET',
                $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
        );
    }

    /**
     * Operation voucherGetCurrency
     *
     * Get the currency of a specified voucher
     *
     * @param  int $id Id of the voucher of which you want to get the currency (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function voucherGetCurrency($id) {
        $this->voucherGetCurrencyWithHttpInfo($id);
    }

    /**
     * Operation voucherGetCurrencyWithHttpInfo
     *
     * Get the currency of a specified voucher
     *
     * @param  int $id Id of the voucher of which you want to get the currency (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function voucherGetCurrencyWithHttpInfo($id) {
        $returnType = '';
        $request = $this->voucherGetCurrencyRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                        "[{$e->getCode()}] {$e->getMessage()}",
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                        sprintf(
                                '[%d] Error connecting to the API (%s)',
                                $statusCode,
                                $request->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation voucherGetCurrencyAsync
     *
     * Get the currency of a specified voucher
     *
     * @param  int $id Id of the voucher of which you want to get the currency (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voucherGetCurrencyAsync($id) {
        return $this->voucherGetCurrencyAsyncWithHttpInfo($id)
                        ->then(
                                function ($response) {
                            return $response[0];
                        }
        );
    }

    /**
     * Operation voucherGetCurrencyAsyncWithHttpInfo
     *
     * Get the currency of a specified voucher
     *
     * @param  int $id Id of the voucher of which you want to get the currency (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voucherGetCurrencyAsyncWithHttpInfo($id) {
        $returnType = '';
        $request = $this->voucherGetCurrencyRequest($id);

        return $this->client
                        ->sendAsync($request, $this->createHttpClientOption())
                        ->then(
                                function ($response) use ($returnType) {
                            return [null, $response->getStatusCode(), $response->getHeaders()];
                        },
                                function ($exception) {
                            $response = $exception->getResponse();
                            $statusCode = $response->getStatusCode();
                            throw new ApiException(
                                    sprintf(
                                            '[%d] Error connecting to the API (%s)',
                                            $statusCode,
                                            $exception->getRequest()->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $response->getBody()
                            );
                        }
        );
    }

    /**
     * Create request for operation 'voucherGetCurrency'
     *
     * @param  int $id Id of the voucher of which you want to get the currency (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function voucherGetCurrencyRequest($id) {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                    'Missing the required parameter $id when calling voucherGetCurrency'
            );
        }

        $resourcePath = '/Voucher/{id}/getCurrency';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                    '{' . 'id' . '}',
                    ObjectSerializer::toPathValue($id),
                    $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                    ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                    ['application/xml', 'application/json'],
                    ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
                $defaultHeaders,
                $headerParams,
                $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
                'GET',
                $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
        );
    }

    /**
     * Operation voucherGetDebit
     *
     * Get unpaid amount of a specified voucher
     *
     * @param  int $id Id of the voucher of which you want to get the unpaid amount (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function voucherGetDebit($id) {
        $this->voucherGetDebitWithHttpInfo($id);
    }

    /**
     * Operation voucherGetDebitWithHttpInfo
     *
     * Get unpaid amount of a specified voucher
     *
     * @param  int $id Id of the voucher of which you want to get the unpaid amount (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function voucherGetDebitWithHttpInfo($id) {
        $returnType = '';
        $request = $this->voucherGetDebitRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                        "[{$e->getCode()}] {$e->getMessage()}",
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                        sprintf(
                                '[%d] Error connecting to the API (%s)',
                                $statusCode,
                                $request->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation voucherGetDebitAsync
     *
     * Get unpaid amount of a specified voucher
     *
     * @param  int $id Id of the voucher of which you want to get the unpaid amount (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voucherGetDebitAsync($id) {
        return $this->voucherGetDebitAsyncWithHttpInfo($id)
                        ->then(
                                function ($response) {
                            return $response[0];
                        }
        );
    }

    /**
     * Operation voucherGetDebitAsyncWithHttpInfo
     *
     * Get unpaid amount of a specified voucher
     *
     * @param  int $id Id of the voucher of which you want to get the unpaid amount (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voucherGetDebitAsyncWithHttpInfo($id) {
        $returnType = '';
        $request = $this->voucherGetDebitRequest($id);

        return $this->client
                        ->sendAsync($request, $this->createHttpClientOption())
                        ->then(
                                function ($response) use ($returnType) {
                            return [null, $response->getStatusCode(), $response->getHeaders()];
                        },
                                function ($exception) {
                            $response = $exception->getResponse();
                            $statusCode = $response->getStatusCode();
                            throw new ApiException(
                                    sprintf(
                                            '[%d] Error connecting to the API (%s)',
                                            $statusCode,
                                            $exception->getRequest()->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $response->getBody()
                            );
                        }
        );
    }

    /**
     * Create request for operation 'voucherGetDebit'
     *
     * @param  int $id Id of the voucher of which you want to get the unpaid amount (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function voucherGetDebitRequest($id) {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                    'Missing the required parameter $id when calling voucherGetDebit'
            );
        }

        $resourcePath = '/Voucher/{id}/getDebit';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                    '{' . 'id' . '}',
                    ObjectSerializer::toPathValue($id),
                    $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                    ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                    ['application/xml', 'application/json'],
                    ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
                $defaultHeaders,
                $headerParams,
                $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
                'GET',
                $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
        );
    }

    /**
     * Operation voucherGetDelinquent
     *
     * Return if the voucher is delinquent
     *
     * @param  int $id Id of the voucher of which you want to know if it is delinquent (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function voucherGetDelinquent($id) {
        $this->voucherGetDelinquentWithHttpInfo($id);
    }

    /**
     * Operation voucherGetDelinquentWithHttpInfo
     *
     * Return if the voucher is delinquent
     *
     * @param  int $id Id of the voucher of which you want to know if it is delinquent (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function voucherGetDelinquentWithHttpInfo($id) {
        $returnType = '';
        $request = $this->voucherGetDelinquentRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                        "[{$e->getCode()}] {$e->getMessage()}",
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                        sprintf(
                                '[%d] Error connecting to the API (%s)',
                                $statusCode,
                                $request->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation voucherGetDelinquentAsync
     *
     * Return if the voucher is delinquent
     *
     * @param  int $id Id of the voucher of which you want to know if it is delinquent (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voucherGetDelinquentAsync($id) {
        return $this->voucherGetDelinquentAsyncWithHttpInfo($id)
                        ->then(
                                function ($response) {
                            return $response[0];
                        }
        );
    }

    /**
     * Operation voucherGetDelinquentAsyncWithHttpInfo
     *
     * Return if the voucher is delinquent
     *
     * @param  int $id Id of the voucher of which you want to know if it is delinquent (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voucherGetDelinquentAsyncWithHttpInfo($id) {
        $returnType = '';
        $request = $this->voucherGetDelinquentRequest($id);

        return $this->client
                        ->sendAsync($request, $this->createHttpClientOption())
                        ->then(
                                function ($response) use ($returnType) {
                            return [null, $response->getStatusCode(), $response->getHeaders()];
                        },
                                function ($exception) {
                            $response = $exception->getResponse();
                            $statusCode = $response->getStatusCode();
                            throw new ApiException(
                                    sprintf(
                                            '[%d] Error connecting to the API (%s)',
                                            $statusCode,
                                            $exception->getRequest()->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $response->getBody()
                            );
                        }
        );
    }

    /**
     * Create request for operation 'voucherGetDelinquent'
     *
     * @param  int $id Id of the voucher of which you want to know if it is delinquent (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function voucherGetDelinquentRequest($id) {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                    'Missing the required parameter $id when calling voucherGetDelinquent'
            );
        }

        $resourcePath = '/Voucher/{id}/getDelinquent';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                    '{' . 'id' . '}',
                    ObjectSerializer::toPathValue($id),
                    $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                    ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                    ['application/xml', 'application/json'],
                    ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
                $defaultHeaders,
                $headerParams,
                $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
                'GET',
                $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
        );
    }

    /**
     * Operation voucherGetDependingRecurringVouchers
     *
     * Get the depending recurring vouchers of a specified origin voucher
     *
     * @param  int $id Id of the voucher of which you want to get the depending recurring vouchers (required)
     * @param  string[] $embed Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ModelVoucher
     */
    public function voucherGetDependingRecurringVouchers($id, $embed = null) {
        list($response) = $this->voucherGetDependingRecurringVouchersWithHttpInfo($id, $embed);
        return $response;
    }

    /**
     * Operation voucherGetDependingRecurringVouchersWithHttpInfo
     *
     * Get the depending recurring vouchers of a specified origin voucher
     *
     * @param  int $id Id of the voucher of which you want to get the depending recurring vouchers (required)
     * @param  string[] $embed Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ModelVoucher, HTTP status code, HTTP response headers (array of strings)
     */
    public function voucherGetDependingRecurringVouchersWithHttpInfo($id, $embed = null) {
        $returnType = '\Swagger\Client\Model\ModelVoucher';
        $request = $this->voucherGetDependingRecurringVouchersRequest($id, $embed);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                        "[{$e->getCode()}] {$e->getMessage()}",
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                        sprintf(
                                '[%d] Error connecting to the API (%s)',
                                $statusCode,
                                $request->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                                    $e->getResponseBody(),
                                    '\Swagger\Client\Model\ModelVoucher',
                                    $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation voucherGetDependingRecurringVouchersAsync
     *
     * Get the depending recurring vouchers of a specified origin voucher
     *
     * @param  int $id Id of the voucher of which you want to get the depending recurring vouchers (required)
     * @param  string[] $embed Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voucherGetDependingRecurringVouchersAsync($id, $embed = null) {
        return $this->voucherGetDependingRecurringVouchersAsyncWithHttpInfo($id, $embed)
                        ->then(
                                function ($response) {
                            return $response[0];
                        }
        );
    }

    /**
     * Operation voucherGetDependingRecurringVouchersAsyncWithHttpInfo
     *
     * Get the depending recurring vouchers of a specified origin voucher
     *
     * @param  int $id Id of the voucher of which you want to get the depending recurring vouchers (required)
     * @param  string[] $embed Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voucherGetDependingRecurringVouchersAsyncWithHttpInfo($id, $embed = null) {
        $returnType = '\Swagger\Client\Model\ModelVoucher';
        $request = $this->voucherGetDependingRecurringVouchersRequest($id, $embed);

        return $this->client
                        ->sendAsync($request, $this->createHttpClientOption())
                        ->then(
                                function ($response) use ($returnType) {
                            $responseBody = $response->getBody();
                            if ($returnType === '\SplFileObject') {
                                $content = $responseBody; //stream goes to serializer
                            } else {
                                $content = $responseBody->getContents();
                                if ($returnType !== 'string') {
                                    $content = json_decode($content);
                                }
                            }

                            return [
                                ObjectSerializer::deserialize($content, $returnType, []),
                                $response->getStatusCode(),
                                $response->getHeaders()
                            ];
                        },
                                function ($exception) {
                            $response = $exception->getResponse();
                            $statusCode = $response->getStatusCode();
                            throw new ApiException(
                                    sprintf(
                                            '[%d] Error connecting to the API (%s)',
                                            $statusCode,
                                            $exception->getRequest()->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $response->getBody()
                            );
                        }
        );
    }

    /**
     * Create request for operation 'voucherGetDependingRecurringVouchers'
     *
     * @param  int $id Id of the voucher of which you want to get the depending recurring vouchers (required)
     * @param  string[] $embed Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function voucherGetDependingRecurringVouchersRequest($id, $embed = null) {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                    'Missing the required parameter $id when calling voucherGetDependingRecurringVouchers'
            );
        }

        $resourcePath = '/Voucher/{id}/getDependingRecurringVouchers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($embed)) {
            $embed = ObjectSerializer::serializeCollection($embed, 'csv', true);
        }
        if ($embed !== null) {
            $queryParams['embed'] = ObjectSerializer::toQueryValue($embed);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                    '{' . 'id' . '}',
                    ObjectSerializer::toPathValue($id),
                    $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                    ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                    ['application/xml', 'application/json'],
                    ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
                $defaultHeaders,
                $headerParams,
                $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
                'GET',
                $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
        );
    }

    /**
     * Operation voucherGetDocumentImage
     *
     * Returns the base64 encoded preview content of the vouchers document
     *
     * @param  int $id Id of the voucher of which you want to get the document image (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function voucherGetDocumentImage($id) {
        $this->voucherGetDocumentImageWithHttpInfo($id);
    }

    /**
     * Operation voucherGetDocumentImageWithHttpInfo
     *
     * Returns the base64 encoded preview content of the vouchers document
     *
     * @param  int $id Id of the voucher of which you want to get the document image (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function voucherGetDocumentImageWithHttpInfo($id) {
        $returnType = '';
        $request = $this->voucherGetDocumentImageRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                        "[{$e->getCode()}] {$e->getMessage()}",
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                        sprintf(
                                '[%d] Error connecting to the API (%s)',
                                $statusCode,
                                $request->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation voucherGetDocumentImageAsync
     *
     * Returns the base64 encoded preview content of the vouchers document
     *
     * @param  int $id Id of the voucher of which you want to get the document image (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voucherGetDocumentImageAsync($id) {
        return $this->voucherGetDocumentImageAsyncWithHttpInfo($id)
                        ->then(
                                function ($response) {
                            return $response[0];
                        }
        );
    }

    /**
     * Operation voucherGetDocumentImageAsyncWithHttpInfo
     *
     * Returns the base64 encoded preview content of the vouchers document
     *
     * @param  int $id Id of the voucher of which you want to get the document image (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voucherGetDocumentImageAsyncWithHttpInfo($id) {
        $returnType = '';
        $request = $this->voucherGetDocumentImageRequest($id);

        return $this->client
                        ->sendAsync($request, $this->createHttpClientOption())
                        ->then(
                                function ($response) use ($returnType) {
                            return [null, $response->getStatusCode(), $response->getHeaders()];
                        },
                                function ($exception) {
                            $response = $exception->getResponse();
                            $statusCode = $response->getStatusCode();
                            throw new ApiException(
                                    sprintf(
                                            '[%d] Error connecting to the API (%s)',
                                            $statusCode,
                                            $exception->getRequest()->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $response->getBody()
                            );
                        }
        );
    }

    /**
     * Create request for operation 'voucherGetDocumentImage'
     *
     * @param  int $id Id of the voucher of which you want to get the document image (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function voucherGetDocumentImageRequest($id) {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                    'Missing the required parameter $id when calling voucherGetDocumentImage'
            );
        }

        $resourcePath = '/Voucher/{id}/getDocumentImage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                    '{' . 'id' . '}',
                    ObjectSerializer::toPathValue($id),
                    $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                    ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                    ['application/xml', 'application/json'],
                    ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
                $defaultHeaders,
                $headerParams,
                $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
                'GET',
                $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
        );
    }

    /**
     * Operation voucherGetTaxGroups
     *
     * Get an overview of all vouchers
     *
     * @param  int $id Id of the voucher you want to update (required)
     * @param  bool $show_total_sum Define if you want to have the total sum of each tax group (required)
     * @param  bool $with_corrections Define if you want to have the total sum with corrections (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function voucherGetTaxGroups($id, $show_total_sum, $with_corrections) {
        $this->voucherGetTaxGroupsWithHttpInfo($id, $show_total_sum, $with_corrections);
    }

    /**
     * Operation voucherGetTaxGroupsWithHttpInfo
     *
     * Get an overview of all vouchers
     *
     * @param  int $id Id of the voucher you want to update (required)
     * @param  bool $show_total_sum Define if you want to have the total sum of each tax group (required)
     * @param  bool $with_corrections Define if you want to have the total sum with corrections (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function voucherGetTaxGroupsWithHttpInfo($id, $show_total_sum, $with_corrections) {
        $returnType = '';
        $request = $this->voucherGetTaxGroupsRequest($id, $show_total_sum, $with_corrections);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                        "[{$e->getCode()}] {$e->getMessage()}",
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                        sprintf(
                                '[%d] Error connecting to the API (%s)',
                                $statusCode,
                                $request->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation voucherGetTaxGroupsAsync
     *
     * Get an overview of all vouchers
     *
     * @param  int $id Id of the voucher you want to update (required)
     * @param  bool $show_total_sum Define if you want to have the total sum of each tax group (required)
     * @param  bool $with_corrections Define if you want to have the total sum with corrections (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voucherGetTaxGroupsAsync($id, $show_total_sum, $with_corrections) {
        return $this->voucherGetTaxGroupsAsyncWithHttpInfo($id, $show_total_sum, $with_corrections)
                        ->then(
                                function ($response) {
                            return $response[0];
                        }
        );
    }

    /**
     * Operation voucherGetTaxGroupsAsyncWithHttpInfo
     *
     * Get an overview of all vouchers
     *
     * @param  int $id Id of the voucher you want to update (required)
     * @param  bool $show_total_sum Define if you want to have the total sum of each tax group (required)
     * @param  bool $with_corrections Define if you want to have the total sum with corrections (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voucherGetTaxGroupsAsyncWithHttpInfo($id, $show_total_sum, $with_corrections) {
        $returnType = '';
        $request = $this->voucherGetTaxGroupsRequest($id, $show_total_sum, $with_corrections);

        return $this->client
                        ->sendAsync($request, $this->createHttpClientOption())
                        ->then(
                                function ($response) use ($returnType) {
                            return [null, $response->getStatusCode(), $response->getHeaders()];
                        },
                                function ($exception) {
                            $response = $exception->getResponse();
                            $statusCode = $response->getStatusCode();
                            throw new ApiException(
                                    sprintf(
                                            '[%d] Error connecting to the API (%s)',
                                            $statusCode,
                                            $exception->getRequest()->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $response->getBody()
                            );
                        }
        );
    }

    /**
     * Create request for operation 'voucherGetTaxGroups'
     *
     * @param  int $id Id of the voucher you want to update (required)
     * @param  bool $show_total_sum Define if you want to have the total sum of each tax group (required)
     * @param  bool $with_corrections Define if you want to have the total sum with corrections (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function voucherGetTaxGroupsRequest($id, $show_total_sum, $with_corrections) {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                    'Missing the required parameter $id when calling voucherGetTaxGroups'
            );
        }
        // verify the required parameter 'show_total_sum' is set
        if ($show_total_sum === null || (is_array($show_total_sum) && count($show_total_sum) === 0)) {
            throw new \InvalidArgumentException(
                    'Missing the required parameter $show_total_sum when calling voucherGetTaxGroups'
            );
        }
        // verify the required parameter 'with_corrections' is set
        if ($with_corrections === null || (is_array($with_corrections) && count($with_corrections) === 0)) {
            throw new \InvalidArgumentException(
                    'Missing the required parameter $with_corrections when calling voucherGetTaxGroups'
            );
        }

        $resourcePath = '/Voucher/{id}/getTaxGroupes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($show_total_sum !== null) {
            $queryParams['showTotalSum'] = ObjectSerializer::toQueryValue($show_total_sum);
        }
        // query params
        if ($with_corrections !== null) {
            $queryParams['withCorrections'] = ObjectSerializer::toQueryValue($with_corrections);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                    '{' . 'id' . '}',
                    ObjectSerializer::toPathValue($id),
                    $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                    ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                    ['application/xml', 'application/json'],
                    ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
                $defaultHeaders,
                $headerParams,
                $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
                'GET',
                $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
        );
    }

    /**
     * Operation voucherMarkAsOpen
     *
     * Mark a specified voucher as open
     *
     * @param  int $id Id of the voucher you want to mark as open (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ModelVoucher
     */
    public function voucherMarkAsOpen($id) {
        list($response) = $this->voucherMarkAsOpenWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation voucherMarkAsOpenWithHttpInfo
     *
     * Mark a specified voucher as open
     *
     * @param  int $id Id of the voucher you want to mark as open (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ModelVoucher, HTTP status code, HTTP response headers (array of strings)
     */
    public function voucherMarkAsOpenWithHttpInfo($id) {
        $returnType = '\Swagger\Client\Model\ModelVoucher';
        $request = $this->voucherMarkAsOpenRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                        "[{$e->getCode()}] {$e->getMessage()}",
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                        sprintf(
                                '[%d] Error connecting to the API (%s)',
                                $statusCode,
                                $request->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                                    $e->getResponseBody(),
                                    '\Swagger\Client\Model\ModelVoucher',
                                    $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation voucherMarkAsOpenAsync
     *
     * Mark a specified voucher as open
     *
     * @param  int $id Id of the voucher you want to mark as open (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voucherMarkAsOpenAsync($id) {
        return $this->voucherMarkAsOpenAsyncWithHttpInfo($id)
                        ->then(
                                function ($response) {
                            return $response[0];
                        }
        );
    }

    /**
     * Operation voucherMarkAsOpenAsyncWithHttpInfo
     *
     * Mark a specified voucher as open
     *
     * @param  int $id Id of the voucher you want to mark as open (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voucherMarkAsOpenAsyncWithHttpInfo($id) {
        $returnType = '\Swagger\Client\Model\ModelVoucher';
        $request = $this->voucherMarkAsOpenRequest($id);

        return $this->client
                        ->sendAsync($request, $this->createHttpClientOption())
                        ->then(
                                function ($response) use ($returnType) {
                            $responseBody = $response->getBody();
                            if ($returnType === '\SplFileObject') {
                                $content = $responseBody; //stream goes to serializer
                            } else {
                                $content = $responseBody->getContents();
                                if ($returnType !== 'string') {
                                    $content = json_decode($content);
                                }
                            }

                            return [
                                ObjectSerializer::deserialize($content, $returnType, []),
                                $response->getStatusCode(),
                                $response->getHeaders()
                            ];
                        },
                                function ($exception) {
                            $response = $exception->getResponse();
                            $statusCode = $response->getStatusCode();
                            throw new ApiException(
                                    sprintf(
                                            '[%d] Error connecting to the API (%s)',
                                            $statusCode,
                                            $exception->getRequest()->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $response->getBody()
                            );
                        }
        );
    }

    /**
     * Create request for operation 'voucherMarkAsOpen'
     *
     * @param  int $id Id of the voucher you want to mark as open (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function voucherMarkAsOpenRequest($id) {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                    'Missing the required parameter $id when calling voucherMarkAsOpen'
            );
        }

        $resourcePath = '/Voucher/{id}/markAsOpen';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                    '{' . 'id' . '}',
                    ObjectSerializer::toPathValue($id),
                    $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                    ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                    ['application/xml', 'application/json'],
                    ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
                $defaultHeaders,
                $headerParams,
                $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
                'PUT',
                $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
        );
    }

    /**
     * Operation voucherMarkAsPaid
     *
     * Mark a specified voucher as paid
     *
     * @param  int $id Id of the voucher you want to mark as paid (required)
     * @param  string $body Enter the date the voucher was paid here, using the format DD.MM.YYYY! (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ModelVoucher
     */
    public function voucherMarkAsPaid($id, $body = null) {
        list($response) = $this->voucherMarkAsPaidWithHttpInfo($id, $body);
        return $response;
    }

    /**
     * Operation voucherMarkAsPaidWithHttpInfo
     *
     * Mark a specified voucher as paid
     *
     * @param  int $id Id of the voucher you want to mark as paid (required)
     * @param  string $body Enter the date the voucher was paid here, using the format DD.MM.YYYY! (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ModelVoucher, HTTP status code, HTTP response headers (array of strings)
     */
    public function voucherMarkAsPaidWithHttpInfo($id, $body = null) {
        $returnType = '\Swagger\Client\Model\ModelVoucher';
        $request = $this->voucherMarkAsPaidRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                        "[{$e->getCode()}] {$e->getMessage()}",
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                        sprintf(
                                '[%d] Error connecting to the API (%s)',
                                $statusCode,
                                $request->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                                    $e->getResponseBody(),
                                    '\Swagger\Client\Model\ModelVoucher',
                                    $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation voucherMarkAsPaidAsync
     *
     * Mark a specified voucher as paid
     *
     * @param  int $id Id of the voucher you want to mark as paid (required)
     * @param  string $body Enter the date the voucher was paid here, using the format DD.MM.YYYY! (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voucherMarkAsPaidAsync($id, $body = null) {
        return $this->voucherMarkAsPaidAsyncWithHttpInfo($id, $body)
                        ->then(
                                function ($response) {
                            return $response[0];
                        }
        );
    }

    /**
     * Operation voucherMarkAsPaidAsyncWithHttpInfo
     *
     * Mark a specified voucher as paid
     *
     * @param  int $id Id of the voucher you want to mark as paid (required)
     * @param  string $body Enter the date the voucher was paid here, using the format DD.MM.YYYY! (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voucherMarkAsPaidAsyncWithHttpInfo($id, $body = null) {
        $returnType = '\Swagger\Client\Model\ModelVoucher';
        $request = $this->voucherMarkAsPaidRequest($id, $body);

        return $this->client
                        ->sendAsync($request, $this->createHttpClientOption())
                        ->then(
                                function ($response) use ($returnType) {
                            $responseBody = $response->getBody();
                            if ($returnType === '\SplFileObject') {
                                $content = $responseBody; //stream goes to serializer
                            } else {
                                $content = $responseBody->getContents();
                                if ($returnType !== 'string') {
                                    $content = json_decode($content);
                                }
                            }

                            return [
                                ObjectSerializer::deserialize($content, $returnType, []),
                                $response->getStatusCode(),
                                $response->getHeaders()
                            ];
                        },
                                function ($exception) {
                            $response = $exception->getResponse();
                            $statusCode = $response->getStatusCode();
                            throw new ApiException(
                                    sprintf(
                                            '[%d] Error connecting to the API (%s)',
                                            $statusCode,
                                            $exception->getRequest()->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $response->getBody()
                            );
                        }
        );
    }

    /**
     * Create request for operation 'voucherMarkAsPaid'
     *
     * @param  int $id Id of the voucher you want to mark as paid (required)
     * @param  string $body Enter the date the voucher was paid here, using the format DD.MM.YYYY! (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function voucherMarkAsPaidRequest($id, $body = null) {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                    'Missing the required parameter $id when calling voucherMarkAsPaid'
            );
        }

        $resourcePath = '/Voucher/{id}/markAsPaid';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                    '{' . 'id' . '}',
                    ObjectSerializer::toPathValue($id),
                    $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                    ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                    ['application/xml', 'application/json'],
                    ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
                $defaultHeaders,
                $headerParams,
                $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
                'PUT',
                $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
        );
    }

    /**
     * Operation voucherRefundAmount
     *
     * Refund an amount for a specified voucher
     *
     * @param  int $id Id of the voucher for which you want to refund an amount (required)
     * @param  string $body Enter the amount which should be refunded, the date of the refund (format DD.MM.YYYY) and if it should appear in the feed an remove the quotation marks! (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ModelVoucherLog
     */
    public function voucherRefundAmount($id, $body = null) {
        list($response) = $this->voucherRefundAmountWithHttpInfo($id, $body);
        return $response;
    }

    /**
     * Operation voucherRefundAmountWithHttpInfo
     *
     * Refund an amount for a specified voucher
     *
     * @param  int $id Id of the voucher for which you want to refund an amount (required)
     * @param  string $body Enter the amount which should be refunded, the date of the refund (format DD.MM.YYYY) and if it should appear in the feed an remove the quotation marks! (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ModelVoucherLog, HTTP status code, HTTP response headers (array of strings)
     */
    public function voucherRefundAmountWithHttpInfo($id, $body = null) {
        $returnType = '\Swagger\Client\Model\ModelVoucherLog';
        $request = $this->voucherRefundAmountRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                        "[{$e->getCode()}] {$e->getMessage()}",
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                        sprintf(
                                '[%d] Error connecting to the API (%s)',
                                $statusCode,
                                $request->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                                    $e->getResponseBody(),
                                    '\Swagger\Client\Model\ModelVoucherLog',
                                    $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation voucherRefundAmountAsync
     *
     * Refund an amount for a specified voucher
     *
     * @param  int $id Id of the voucher for which you want to refund an amount (required)
     * @param  string $body Enter the amount which should be refunded, the date of the refund (format DD.MM.YYYY) and if it should appear in the feed an remove the quotation marks! (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voucherRefundAmountAsync($id, $body = null) {
        return $this->voucherRefundAmountAsyncWithHttpInfo($id, $body)
                        ->then(
                                function ($response) {
                            return $response[0];
                        }
        );
    }

    /**
     * Operation voucherRefundAmountAsyncWithHttpInfo
     *
     * Refund an amount for a specified voucher
     *
     * @param  int $id Id of the voucher for which you want to refund an amount (required)
     * @param  string $body Enter the amount which should be refunded, the date of the refund (format DD.MM.YYYY) and if it should appear in the feed an remove the quotation marks! (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voucherRefundAmountAsyncWithHttpInfo($id, $body = null) {
        $returnType = '\Swagger\Client\Model\ModelVoucherLog';
        $request = $this->voucherRefundAmountRequest($id, $body);

        return $this->client
                        ->sendAsync($request, $this->createHttpClientOption())
                        ->then(
                                function ($response) use ($returnType) {
                            $responseBody = $response->getBody();
                            if ($returnType === '\SplFileObject') {
                                $content = $responseBody; //stream goes to serializer
                            } else {
                                $content = $responseBody->getContents();
                                if ($returnType !== 'string') {
                                    $content = json_decode($content);
                                }
                            }

                            return [
                                ObjectSerializer::deserialize($content, $returnType, []),
                                $response->getStatusCode(),
                                $response->getHeaders()
                            ];
                        },
                                function ($exception) {
                            $response = $exception->getResponse();
                            $statusCode = $response->getStatusCode();
                            throw new ApiException(
                                    sprintf(
                                            '[%d] Error connecting to the API (%s)',
                                            $statusCode,
                                            $exception->getRequest()->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $response->getBody()
                            );
                        }
        );
    }

    /**
     * Create request for operation 'voucherRefundAmount'
     *
     * @param  int $id Id of the voucher for which you want to refund an amount (required)
     * @param  string $body Enter the amount which should be refunded, the date of the refund (format DD.MM.YYYY) and if it should appear in the feed an remove the quotation marks! (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function voucherRefundAmountRequest($id, $body = null) {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                    'Missing the required parameter $id when calling voucherRefundAmount'
            );
        }

        $resourcePath = '/Voucher/{id}/refundAmmount';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                    '{' . 'id' . '}',
                    ObjectSerializer::toPathValue($id),
                    $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                    ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                    ['application/xml', 'application/json'],
                    ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
                $defaultHeaders,
                $headerParams,
                $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
                'PUT',
                $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
        );
    }

    /**
     * Operation voucherUploadTempFile
     *
     * Upload a temporary file to be used later
     *
     * @param  \SplFileObject $file file to upload (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ModelVoucherFactory
     */
    public function voucherUploadTempFile($file) {
        list($response) = $this->voucherUploadTempFileWithHttpInfo($file);
        return $response;
    }

    /**
     * Operation voucherUploadTempFileWithHttpInfo
     *
     * Upload a temporary file to be used later
     *
     * @param  \SplFileObject $file file to upload (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ModelVoucherFactory, HTTP status code, HTTP response headers (array of strings)
     */
    public function voucherUploadTempFileWithHttpInfo($file) {
        $returnType = '\Swagger\Client\Model\ModelVoucherFactory';
        $request = $this->voucherUploadTempFileRequest($file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                        "[{$e->getCode()}] {$e->getMessage()}",
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                        sprintf(
                                '[%d] Error connecting to the API (%s)',
                                $statusCode,
                                $request->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content, true);
                }
            }

            return [
                $content,
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                                    $e->getResponseBody(),
                                    '\Swagger\Client\Model\ModelVoucherFactory',
                                    $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation voucherUploadTempFileAsync
     *
     * Upload a temporary file to be used later
     *
     * @param  \SplFileObject $file file to upload (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voucherUploadTempFileAsync($file) {
        return $this->voucherUploadTempFileAsyncWithHttpInfo($file)
                        ->then(
                                function ($response) {
                            return $response[0];
                        }
        );
    }

    /**
     * Operation voucherUploadTempFileAsyncWithHttpInfo
     *
     * Upload a temporary file to be used later
     *
     * @param  \SplFileObject $file file to upload (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voucherUploadTempFileAsyncWithHttpInfo($file) {
        $returnType = '\Swagger\Client\Model\ModelVoucherFactory';
        $request = $this->voucherUploadTempFileRequest($file);

        return $this->client
                        ->sendAsync($request, $this->createHttpClientOption())
                        ->then(
                                function ($response) use ($returnType) {
                            $responseBody = $response->getBody();
                            if ($returnType === '\SplFileObject') {
                                $content = $responseBody; //stream goes to serializer
                            } else {
                                $content = $responseBody->getContents();
                                if ($returnType !== 'string') {
                                    $content = json_decode($content);
                                }
                            }

                            return [
                                ObjectSerializer::deserialize($content, $returnType, []),
                                $response->getStatusCode(),
                                $response->getHeaders()
                            ];
                        },
                                function ($exception) {
                            $response = $exception->getResponse();
                            $statusCode = $response->getStatusCode();
                            throw new ApiException(
                                    sprintf(
                                            '[%d] Error connecting to the API (%s)',
                                            $statusCode,
                                            $exception->getRequest()->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $response->getBody()
                            );
                        }
        );
    }

    /**
     * Create request for operation 'voucherUploadTempFile'
     *
     * @param  \SplFileObject $file file to upload (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function voucherUploadTempFileRequest($file) {
        // verify the required parameter 'file' is set
        if ($file === null || (is_array($file) && count($file) === 0)) {
            throw new \InvalidArgumentException(
                    'Missing the required parameter $file when calling voucherUploadTempFile'
            );
        }

        $resourcePath = '/Voucher/Factory/uploadTempFile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                    ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                    ['application/xml', 'application/json'],
                    ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
                $defaultHeaders,
                $headerParams,
                $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
                'POST',
                $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption() {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }

}
