<?php
/**
 * ReportApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * sevDesk
 *
 * # Getting started  The sevDesk API v1 uses a token authentication.    You need to click on the authorization button (lock symbol) and enter your api-key there.    The token can be found on [https://my.sevdesk.de](https://my.sevdesk.de).    settings-->user-->specific user    # General information    The sevDesk api uses **models** to represent the different categories like **contacts** and **invoices**.    Every time you request such a model from the api, it will return the whole model schema including the unique **model id** and all the other objects and parameters that are included in the model.    Have a look at it in the developer console of your desired browser, especially if you are looking for specific parameters like the model id.    # URL    The basic URL contains four elements. **BaseURL** + **Controller** + **Version** + **Model**: [https://my.sevdesk.de/api/v1/Contact/](https://my.sevdesk.de/api/v1/Contact/)    # Basic Operations    Access a list of models: [https://my.sevdesk.de/api/v1/{Model}/](https://my.sevdesk.de/api/v1/{Model}/)    Access a specific model: [https://my.sevdesk.de/api/v1/{Model}/{id}](https://my.sevdesk.de/api/v1/{Model}/{id})    The **id** of a specific model can usually be found in the **developer console** of your browser or when opening a specific model, in the **url**.    Call a model function: [https://my.sevdesk.de/api/v1/{Model}/{id}/{Function}](https://my.sevdesk.de/api/v1/{Model}/{id}/{Function})    Each operation can be used with different HTTP methods:  * GET - read data  * POST - create data  * PUT - update existing data  * DELETE - delete data    # Useful Parameters    For each request, there are some specific parameters.    **GET Query Parameters**  * **limit** - limits the number of entries returned  * **offset** - set the index where the returned entries should start  * **embed** - embed can be used to get some additional information about a model. For example you can get the addresses of a contact with **embed=addresses**    `[GET]https://my.sevdesk.de/api/v1/Contact/?embed=addresses`    * If there is a need to get more information about the country in the addresses, embed can be extended by **addresses.country**    `[GET]https://my.sevdesk.de/api/v1/Contact/?embed=addresses,addresses.country`    * Some models also contain other models. By default these models are only filled with an id and objectName. If you want to get more information about the nested model you can use embed too.    `[GET]https://my.sevdesk.de/api/v1/Contact/?embed=parent`    * Every model also has specified 'query parameters'. These can be used to filter the results. E.g. all Contacts with a 'Company' in their name    `[GET]https://my.sevdesk.de/api/v1/Contact/?name=Company`    * **countAll** If countAll is set to 1 the total number of entries will be returned additionally  * **orderBy** Is an array that can be filled with objects containing the the properties field and arrangement    `json: orderBy = [{field:'parent' ,arrangement:'desc'},{field:'name' ,arrangement:'asc'}];`    `url: ?orderBy[0][field]=parent&orderBy[0][arrangement]=desc&orderBy[1][field]=name&orderBy[1][arrangement]=asc`
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.4
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * ReportApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ReportApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation reportContact
     *
     * Export the contact
     *
     * @param  bool $download Specifies if the document is downloaded (required)
     * @param  int $contact_id Id of contact which should be exported (required)
     * @param  string $contact_object_name Model name which is exported (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function reportContact($download, $contact_id, $contact_object_name)
    {
        list($response) = $this->reportContactWithHttpInfo($download, $contact_id, $contact_object_name);
        return $response;
    }

    /**
     * Operation reportContactWithHttpInfo
     *
     * Export the contact
     *
     * @param  bool $download Specifies if the document is downloaded (required)
     * @param  int $contact_id Id of contact which should be exported (required)
     * @param  string $contact_object_name Model name which is exported (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportContactWithHttpInfo($download, $contact_id, $contact_object_name)
    {
        $returnType = '\SplFileObject';
        $request = $this->reportContactRequest($download, $contact_id, $contact_object_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reportContactAsync
     *
     * Export the contact
     *
     * @param  bool $download Specifies if the document is downloaded (required)
     * @param  int $contact_id Id of contact which should be exported (required)
     * @param  string $contact_object_name Model name which is exported (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportContactAsync($download, $contact_id, $contact_object_name)
    {
        return $this->reportContactAsyncWithHttpInfo($download, $contact_id, $contact_object_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportContactAsyncWithHttpInfo
     *
     * Export the contact
     *
     * @param  bool $download Specifies if the document is downloaded (required)
     * @param  int $contact_id Id of contact which should be exported (required)
     * @param  string $contact_object_name Model name which is exported (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportContactAsyncWithHttpInfo($download, $contact_id, $contact_object_name)
    {
        $returnType = '\SplFileObject';
        $request = $this->reportContactRequest($download, $contact_id, $contact_object_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportContact'
     *
     * @param  bool $download Specifies if the document is downloaded (required)
     * @param  int $contact_id Id of contact which should be exported (required)
     * @param  string $contact_object_name Model name which is exported (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reportContactRequest($download, $contact_id, $contact_object_name)
    {
        // verify the required parameter 'download' is set
        if ($download === null || (is_array($download) && count($download) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $download when calling reportContact'
            );
        }
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling reportContact'
            );
        }
        // verify the required parameter 'contact_object_name' is set
        if ($contact_object_name === null || (is_array($contact_object_name) && count($contact_object_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_object_name when calling reportContact'
            );
        }

        $resourcePath = '/Report/contact';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($download !== null) {
            $queryParams['download'] = ObjectSerializer::toQueryValue($download);
        }
        // query params
        if ($contact_id !== null) {
            $queryParams['contact[id]'] = ObjectSerializer::toQueryValue($contact_id);
        }
        // query params
        if ($contact_object_name !== null) {
            $queryParams['contact[objectName]'] = ObjectSerializer::toQueryValue($contact_object_name);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/pdf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/pdf'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportContactList
     *
     * Export the contact list
     *
     * @param  string $sev_query_model_name Model name which is exported (required)
     * @param  string $sev_query_object_name SevQuery object name (required)
     * @param  bool $download Specifies if the document is downloaded (optional, default to true)
     * @param  int $sev_query_limit Limit exported contacts (optional, default to 99999)
     * @param  int $sev_query_offset Set the index where the exported contacts start (optional, default to 0)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function reportContactList($sev_query_model_name, $sev_query_object_name, $download = 'true', $sev_query_limit = '99999', $sev_query_offset = '0')
    {
        list($response) = $this->reportContactListWithHttpInfo($sev_query_model_name, $sev_query_object_name, $download, $sev_query_limit, $sev_query_offset);
        return $response;
    }

    /**
     * Operation reportContactListWithHttpInfo
     *
     * Export the contact list
     *
     * @param  string $sev_query_model_name Model name which is exported (required)
     * @param  string $sev_query_object_name SevQuery object name (required)
     * @param  bool $download Specifies if the document is downloaded (optional, default to true)
     * @param  int $sev_query_limit Limit exported contacts (optional, default to 99999)
     * @param  int $sev_query_offset Set the index where the exported contacts start (optional, default to 0)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportContactListWithHttpInfo($sev_query_model_name, $sev_query_object_name, $download = 'true', $sev_query_limit = '99999', $sev_query_offset = '0')
    {
        $returnType = '\SplFileObject';
        $request = $this->reportContactListRequest($sev_query_model_name, $sev_query_object_name, $download, $sev_query_limit, $sev_query_offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reportContactListAsync
     *
     * Export the contact list
     *
     * @param  string $sev_query_model_name Model name which is exported (required)
     * @param  string $sev_query_object_name SevQuery object name (required)
     * @param  bool $download Specifies if the document is downloaded (optional, default to true)
     * @param  int $sev_query_limit Limit exported contacts (optional, default to 99999)
     * @param  int $sev_query_offset Set the index where the exported contacts start (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportContactListAsync($sev_query_model_name, $sev_query_object_name, $download = 'true', $sev_query_limit = '99999', $sev_query_offset = '0')
    {
        return $this->reportContactListAsyncWithHttpInfo($sev_query_model_name, $sev_query_object_name, $download, $sev_query_limit, $sev_query_offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportContactListAsyncWithHttpInfo
     *
     * Export the contact list
     *
     * @param  string $sev_query_model_name Model name which is exported (required)
     * @param  string $sev_query_object_name SevQuery object name (required)
     * @param  bool $download Specifies if the document is downloaded (optional, default to true)
     * @param  int $sev_query_limit Limit exported contacts (optional, default to 99999)
     * @param  int $sev_query_offset Set the index where the exported contacts start (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportContactListAsyncWithHttpInfo($sev_query_model_name, $sev_query_object_name, $download = 'true', $sev_query_limit = '99999', $sev_query_offset = '0')
    {
        $returnType = '\SplFileObject';
        $request = $this->reportContactListRequest($sev_query_model_name, $sev_query_object_name, $download, $sev_query_limit, $sev_query_offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportContactList'
     *
     * @param  string $sev_query_model_name Model name which is exported (required)
     * @param  string $sev_query_object_name SevQuery object name (required)
     * @param  bool $download Specifies if the document is downloaded (optional, default to true)
     * @param  int $sev_query_limit Limit exported contacts (optional, default to 99999)
     * @param  int $sev_query_offset Set the index where the exported contacts start (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reportContactListRequest($sev_query_model_name, $sev_query_object_name, $download = 'true', $sev_query_limit = '99999', $sev_query_offset = '0')
    {
        // verify the required parameter 'sev_query_model_name' is set
        if ($sev_query_model_name === null || (is_array($sev_query_model_name) && count($sev_query_model_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sev_query_model_name when calling reportContactList'
            );
        }
        // verify the required parameter 'sev_query_object_name' is set
        if ($sev_query_object_name === null || (is_array($sev_query_object_name) && count($sev_query_object_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sev_query_object_name when calling reportContactList'
            );
        }

        $resourcePath = '/Report/contactlist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($download !== null) {
            $queryParams['download'] = ObjectSerializer::toQueryValue($download);
        }
        // query params
        if ($sev_query_limit !== null) {
            $queryParams['sevQuery[limit]'] = ObjectSerializer::toQueryValue($sev_query_limit);
        }
        // query params
        if ($sev_query_offset !== null) {
            $queryParams['sevQuery[offset]'] = ObjectSerializer::toQueryValue($sev_query_offset);
        }
        // query params
        if ($sev_query_model_name !== null) {
            $queryParams['sevQuery[modelName]'] = ObjectSerializer::toQueryValue($sev_query_model_name);
        }
        // query params
        if ($sev_query_object_name !== null) {
            $queryParams['sevQuery[objectName]'] = ObjectSerializer::toQueryValue($sev_query_object_name);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/pdf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/pdf'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportInventory
     *
     * Export the inventory
     *
     * @param  string $sev_query_model_name Model name which is exported (required)
     * @param  string $sev_query_object_name SevQuery object name (required)
     * @param  bool $download Specifies if the document is downloaded (optional, default to true)
     * @param  int $sev_query_limit Limit exported inventory entries (optional, default to 99999)
     * @param  int $sev_query_offset Set the index where the exported parts start (optional, default to 99999)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function reportInventory($sev_query_model_name, $sev_query_object_name, $download = 'true', $sev_query_limit = '99999', $sev_query_offset = '99999')
    {
        list($response) = $this->reportInventoryWithHttpInfo($sev_query_model_name, $sev_query_object_name, $download, $sev_query_limit, $sev_query_offset);
        return $response;
    }

    /**
     * Operation reportInventoryWithHttpInfo
     *
     * Export the inventory
     *
     * @param  string $sev_query_model_name Model name which is exported (required)
     * @param  string $sev_query_object_name SevQuery object name (required)
     * @param  bool $download Specifies if the document is downloaded (optional, default to true)
     * @param  int $sev_query_limit Limit exported inventory entries (optional, default to 99999)
     * @param  int $sev_query_offset Set the index where the exported parts start (optional, default to 99999)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportInventoryWithHttpInfo($sev_query_model_name, $sev_query_object_name, $download = 'true', $sev_query_limit = '99999', $sev_query_offset = '99999')
    {
        $returnType = '\SplFileObject';
        $request = $this->reportInventoryRequest($sev_query_model_name, $sev_query_object_name, $download, $sev_query_limit, $sev_query_offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reportInventoryAsync
     *
     * Export the inventory
     *
     * @param  string $sev_query_model_name Model name which is exported (required)
     * @param  string $sev_query_object_name SevQuery object name (required)
     * @param  bool $download Specifies if the document is downloaded (optional, default to true)
     * @param  int $sev_query_limit Limit exported inventory entries (optional, default to 99999)
     * @param  int $sev_query_offset Set the index where the exported parts start (optional, default to 99999)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportInventoryAsync($sev_query_model_name, $sev_query_object_name, $download = 'true', $sev_query_limit = '99999', $sev_query_offset = '99999')
    {
        return $this->reportInventoryAsyncWithHttpInfo($sev_query_model_name, $sev_query_object_name, $download, $sev_query_limit, $sev_query_offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportInventoryAsyncWithHttpInfo
     *
     * Export the inventory
     *
     * @param  string $sev_query_model_name Model name which is exported (required)
     * @param  string $sev_query_object_name SevQuery object name (required)
     * @param  bool $download Specifies if the document is downloaded (optional, default to true)
     * @param  int $sev_query_limit Limit exported inventory entries (optional, default to 99999)
     * @param  int $sev_query_offset Set the index where the exported parts start (optional, default to 99999)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportInventoryAsyncWithHttpInfo($sev_query_model_name, $sev_query_object_name, $download = 'true', $sev_query_limit = '99999', $sev_query_offset = '99999')
    {
        $returnType = '\SplFileObject';
        $request = $this->reportInventoryRequest($sev_query_model_name, $sev_query_object_name, $download, $sev_query_limit, $sev_query_offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportInventory'
     *
     * @param  string $sev_query_model_name Model name which is exported (required)
     * @param  string $sev_query_object_name SevQuery object name (required)
     * @param  bool $download Specifies if the document is downloaded (optional, default to true)
     * @param  int $sev_query_limit Limit exported inventory entries (optional, default to 99999)
     * @param  int $sev_query_offset Set the index where the exported parts start (optional, default to 99999)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reportInventoryRequest($sev_query_model_name, $sev_query_object_name, $download = 'true', $sev_query_limit = '99999', $sev_query_offset = '99999')
    {
        // verify the required parameter 'sev_query_model_name' is set
        if ($sev_query_model_name === null || (is_array($sev_query_model_name) && count($sev_query_model_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sev_query_model_name when calling reportInventory'
            );
        }
        // verify the required parameter 'sev_query_object_name' is set
        if ($sev_query_object_name === null || (is_array($sev_query_object_name) && count($sev_query_object_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sev_query_object_name when calling reportInventory'
            );
        }

        $resourcePath = '/Report/inventory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($download !== null) {
            $queryParams['download'] = ObjectSerializer::toQueryValue($download);
        }
        // query params
        if ($sev_query_limit !== null) {
            $queryParams['sevQuery[limit]'] = ObjectSerializer::toQueryValue($sev_query_limit);
        }
        // query params
        if ($sev_query_offset !== null) {
            $queryParams['sevQuery[offset]'] = ObjectSerializer::toQueryValue($sev_query_offset);
        }
        // query params
        if ($sev_query_model_name !== null) {
            $queryParams['sevQuery[modelName]'] = ObjectSerializer::toQueryValue($sev_query_model_name);
        }
        // query params
        if ($sev_query_object_name !== null) {
            $queryParams['sevQuery[objectName]'] = ObjectSerializer::toQueryValue($sev_query_object_name);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/pdf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/pdf'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportInvoiceList
     *
     * Export the invoicelist
     *
     * @param  string $sev_query_model_name Model name which is exported (required)
     * @param  string $sev_query_object_name SevQuery object name (required)
     * @param  bool $download Specifies if the document is downloaded (optional, default to true)
     * @param  int $sev_query_limit Limit exported invoices (optional, default to 99999)
     * @param  int $sev_query_offset Set the index where the exported invoices should start (optional, default to 0)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function reportInvoiceList($sev_query_model_name, $sev_query_object_name, $download = 'true', $sev_query_limit = '99999', $sev_query_offset = '0')
    {
        list($response) = $this->reportInvoiceListWithHttpInfo($sev_query_model_name, $sev_query_object_name, $download, $sev_query_limit, $sev_query_offset);
        return $response;
    }

    /**
     * Operation reportInvoiceListWithHttpInfo
     *
     * Export the invoicelist
     *
     * @param  string $sev_query_model_name Model name which is exported (required)
     * @param  string $sev_query_object_name SevQuery object name (required)
     * @param  bool $download Specifies if the document is downloaded (optional, default to true)
     * @param  int $sev_query_limit Limit exported invoices (optional, default to 99999)
     * @param  int $sev_query_offset Set the index where the exported invoices should start (optional, default to 0)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportInvoiceListWithHttpInfo($sev_query_model_name, $sev_query_object_name, $download = 'true', $sev_query_limit = '99999', $sev_query_offset = '0')
    {
        $returnType = '\SplFileObject';
        $request = $this->reportInvoiceListRequest($sev_query_model_name, $sev_query_object_name, $download, $sev_query_limit, $sev_query_offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reportInvoiceListAsync
     *
     * Export the invoicelist
     *
     * @param  string $sev_query_model_name Model name which is exported (required)
     * @param  string $sev_query_object_name SevQuery object name (required)
     * @param  bool $download Specifies if the document is downloaded (optional, default to true)
     * @param  int $sev_query_limit Limit exported invoices (optional, default to 99999)
     * @param  int $sev_query_offset Set the index where the exported invoices should start (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportInvoiceListAsync($sev_query_model_name, $sev_query_object_name, $download = 'true', $sev_query_limit = '99999', $sev_query_offset = '0')
    {
        return $this->reportInvoiceListAsyncWithHttpInfo($sev_query_model_name, $sev_query_object_name, $download, $sev_query_limit, $sev_query_offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportInvoiceListAsyncWithHttpInfo
     *
     * Export the invoicelist
     *
     * @param  string $sev_query_model_name Model name which is exported (required)
     * @param  string $sev_query_object_name SevQuery object name (required)
     * @param  bool $download Specifies if the document is downloaded (optional, default to true)
     * @param  int $sev_query_limit Limit exported invoices (optional, default to 99999)
     * @param  int $sev_query_offset Set the index where the exported invoices should start (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportInvoiceListAsyncWithHttpInfo($sev_query_model_name, $sev_query_object_name, $download = 'true', $sev_query_limit = '99999', $sev_query_offset = '0')
    {
        $returnType = '\SplFileObject';
        $request = $this->reportInvoiceListRequest($sev_query_model_name, $sev_query_object_name, $download, $sev_query_limit, $sev_query_offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportInvoiceList'
     *
     * @param  string $sev_query_model_name Model name which is exported (required)
     * @param  string $sev_query_object_name SevQuery object name (required)
     * @param  bool $download Specifies if the document is downloaded (optional, default to true)
     * @param  int $sev_query_limit Limit exported invoices (optional, default to 99999)
     * @param  int $sev_query_offset Set the index where the exported invoices should start (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reportInvoiceListRequest($sev_query_model_name, $sev_query_object_name, $download = 'true', $sev_query_limit = '99999', $sev_query_offset = '0')
    {
        // verify the required parameter 'sev_query_model_name' is set
        if ($sev_query_model_name === null || (is_array($sev_query_model_name) && count($sev_query_model_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sev_query_model_name when calling reportInvoiceList'
            );
        }
        // verify the required parameter 'sev_query_object_name' is set
        if ($sev_query_object_name === null || (is_array($sev_query_object_name) && count($sev_query_object_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sev_query_object_name when calling reportInvoiceList'
            );
        }

        $resourcePath = '/Report/invoicelist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($download !== null) {
            $queryParams['download'] = ObjectSerializer::toQueryValue($download);
        }
        // query params
        if ($sev_query_limit !== null) {
            $queryParams['sevQuery[limit]'] = ObjectSerializer::toQueryValue($sev_query_limit);
        }
        // query params
        if ($sev_query_offset !== null) {
            $queryParams['sevQuery[offset]'] = ObjectSerializer::toQueryValue($sev_query_offset);
        }
        // query params
        if ($sev_query_model_name !== null) {
            $queryParams['sevQuery[modelName]'] = ObjectSerializer::toQueryValue($sev_query_model_name);
        }
        // query params
        if ($sev_query_object_name !== null) {
            $queryParams['sevQuery[objectName]'] = ObjectSerializer::toQueryValue($sev_query_object_name);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/pdf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/pdf'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportOrderList
     *
     * Export the order list
     *
     * @param  string $sev_query_model_name Model name which is exported (required)
     * @param  string $sev_query_object_name SevQuery object name (required)
     * @param  bool $download Specifies if the document is downloaded (optional, default to true)
     * @param  int $sev_query_limit Limit exported orders (optional, default to 99999)
     * @param  int $sev_query_offset Set the index where the exported orders should start (optional, default to 0)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function reportOrderList($sev_query_model_name, $sev_query_object_name, $download = 'true', $sev_query_limit = '99999', $sev_query_offset = '0')
    {
        list($response) = $this->reportOrderListWithHttpInfo($sev_query_model_name, $sev_query_object_name, $download, $sev_query_limit, $sev_query_offset);
        return $response;
    }

    /**
     * Operation reportOrderListWithHttpInfo
     *
     * Export the order list
     *
     * @param  string $sev_query_model_name Model name which is exported (required)
     * @param  string $sev_query_object_name SevQuery object name (required)
     * @param  bool $download Specifies if the document is downloaded (optional, default to true)
     * @param  int $sev_query_limit Limit exported orders (optional, default to 99999)
     * @param  int $sev_query_offset Set the index where the exported orders should start (optional, default to 0)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportOrderListWithHttpInfo($sev_query_model_name, $sev_query_object_name, $download = 'true', $sev_query_limit = '99999', $sev_query_offset = '0')
    {
        $returnType = '\SplFileObject';
        $request = $this->reportOrderListRequest($sev_query_model_name, $sev_query_object_name, $download, $sev_query_limit, $sev_query_offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reportOrderListAsync
     *
     * Export the order list
     *
     * @param  string $sev_query_model_name Model name which is exported (required)
     * @param  string $sev_query_object_name SevQuery object name (required)
     * @param  bool $download Specifies if the document is downloaded (optional, default to true)
     * @param  int $sev_query_limit Limit exported orders (optional, default to 99999)
     * @param  int $sev_query_offset Set the index where the exported orders should start (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportOrderListAsync($sev_query_model_name, $sev_query_object_name, $download = 'true', $sev_query_limit = '99999', $sev_query_offset = '0')
    {
        return $this->reportOrderListAsyncWithHttpInfo($sev_query_model_name, $sev_query_object_name, $download, $sev_query_limit, $sev_query_offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportOrderListAsyncWithHttpInfo
     *
     * Export the order list
     *
     * @param  string $sev_query_model_name Model name which is exported (required)
     * @param  string $sev_query_object_name SevQuery object name (required)
     * @param  bool $download Specifies if the document is downloaded (optional, default to true)
     * @param  int $sev_query_limit Limit exported orders (optional, default to 99999)
     * @param  int $sev_query_offset Set the index where the exported orders should start (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportOrderListAsyncWithHttpInfo($sev_query_model_name, $sev_query_object_name, $download = 'true', $sev_query_limit = '99999', $sev_query_offset = '0')
    {
        $returnType = '\SplFileObject';
        $request = $this->reportOrderListRequest($sev_query_model_name, $sev_query_object_name, $download, $sev_query_limit, $sev_query_offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportOrderList'
     *
     * @param  string $sev_query_model_name Model name which is exported (required)
     * @param  string $sev_query_object_name SevQuery object name (required)
     * @param  bool $download Specifies if the document is downloaded (optional, default to true)
     * @param  int $sev_query_limit Limit exported orders (optional, default to 99999)
     * @param  int $sev_query_offset Set the index where the exported orders should start (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reportOrderListRequest($sev_query_model_name, $sev_query_object_name, $download = 'true', $sev_query_limit = '99999', $sev_query_offset = '0')
    {
        // verify the required parameter 'sev_query_model_name' is set
        if ($sev_query_model_name === null || (is_array($sev_query_model_name) && count($sev_query_model_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sev_query_model_name when calling reportOrderList'
            );
        }
        // verify the required parameter 'sev_query_object_name' is set
        if ($sev_query_object_name === null || (is_array($sev_query_object_name) && count($sev_query_object_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sev_query_object_name when calling reportOrderList'
            );
        }

        $resourcePath = '/Report/orderlist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($download !== null) {
            $queryParams['download'] = ObjectSerializer::toQueryValue($download);
        }
        // query params
        if ($sev_query_limit !== null) {
            $queryParams['sevQuery[limit]'] = ObjectSerializer::toQueryValue($sev_query_limit);
        }
        // query params
        if ($sev_query_offset !== null) {
            $queryParams['sevQuery[offset]'] = ObjectSerializer::toQueryValue($sev_query_offset);
        }
        // query params
        if ($sev_query_model_name !== null) {
            $queryParams['sevQuery[modelName]'] = ObjectSerializer::toQueryValue($sev_query_model_name);
        }
        // query params
        if ($sev_query_object_name !== null) {
            $queryParams['sevQuery[objectName]'] = ObjectSerializer::toQueryValue($sev_query_object_name);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/pdf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/pdf'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportProfitAndLoss
     *
     * Export the profit and loss
     *
     * @param  string $start_date Start date of the profit and loss calculation (required)
     * @param  string $end_date End date of the profit and loss calculation (required)
     * @param  bool $tax_rule Specify if you want the net income method or the profit and loss (required)
     * @param  bool $download Specifies if the document is downloaded (optional, default to true)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function reportProfitAndLoss($start_date, $end_date, $tax_rule, $download = 'true')
    {
        list($response) = $this->reportProfitAndLossWithHttpInfo($start_date, $end_date, $tax_rule, $download);
        return $response;
    }

    /**
     * Operation reportProfitAndLossWithHttpInfo
     *
     * Export the profit and loss
     *
     * @param  string $start_date Start date of the profit and loss calculation (required)
     * @param  string $end_date End date of the profit and loss calculation (required)
     * @param  bool $tax_rule Specify if you want the net income method or the profit and loss (required)
     * @param  bool $download Specifies if the document is downloaded (optional, default to true)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportProfitAndLossWithHttpInfo($start_date, $end_date, $tax_rule, $download = 'true')
    {
        $returnType = '\SplFileObject';
        $request = $this->reportProfitAndLossRequest($start_date, $end_date, $tax_rule, $download);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reportProfitAndLossAsync
     *
     * Export the profit and loss
     *
     * @param  string $start_date Start date of the profit and loss calculation (required)
     * @param  string $end_date End date of the profit and loss calculation (required)
     * @param  bool $tax_rule Specify if you want the net income method or the profit and loss (required)
     * @param  bool $download Specifies if the document is downloaded (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportProfitAndLossAsync($start_date, $end_date, $tax_rule, $download = 'true')
    {
        return $this->reportProfitAndLossAsyncWithHttpInfo($start_date, $end_date, $tax_rule, $download)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportProfitAndLossAsyncWithHttpInfo
     *
     * Export the profit and loss
     *
     * @param  string $start_date Start date of the profit and loss calculation (required)
     * @param  string $end_date End date of the profit and loss calculation (required)
     * @param  bool $tax_rule Specify if you want the net income method or the profit and loss (required)
     * @param  bool $download Specifies if the document is downloaded (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportProfitAndLossAsyncWithHttpInfo($start_date, $end_date, $tax_rule, $download = 'true')
    {
        $returnType = '\SplFileObject';
        $request = $this->reportProfitAndLossRequest($start_date, $end_date, $tax_rule, $download);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportProfitAndLoss'
     *
     * @param  string $start_date Start date of the profit and loss calculation (required)
     * @param  string $end_date End date of the profit and loss calculation (required)
     * @param  bool $tax_rule Specify if you want the net income method or the profit and loss (required)
     * @param  bool $download Specifies if the document is downloaded (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reportProfitAndLossRequest($start_date, $end_date, $tax_rule, $download = 'true')
    {
        // verify the required parameter 'start_date' is set
        if ($start_date === null || (is_array($start_date) && count($start_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $start_date when calling reportProfitAndLoss'
            );
        }
        // verify the required parameter 'end_date' is set
        if ($end_date === null || (is_array($end_date) && count($end_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $end_date when calling reportProfitAndLoss'
            );
        }
        // verify the required parameter 'tax_rule' is set
        if ($tax_rule === null || (is_array($tax_rule) && count($tax_rule) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tax_rule when calling reportProfitAndLoss'
            );
        }

        $resourcePath = '/Report/profitAndLoss';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($download !== null) {
            $queryParams['download'] = ObjectSerializer::toQueryValue($download);
        }
        // query params
        if ($start_date !== null) {
            $queryParams['startDate'] = ObjectSerializer::toQueryValue($start_date);
        }
        // query params
        if ($end_date !== null) {
            $queryParams['endDate'] = ObjectSerializer::toQueryValue($end_date);
        }
        // query params
        if ($tax_rule !== null) {
            $queryParams['taxRule'] = ObjectSerializer::toQueryValue($tax_rule);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/pdf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/pdf'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportRegisterBook
     *
     * Export the register book / cash report
     *
     * @param  int $check_account_id Check account you want to export (required)
     * @param  string $check_account_object_name Check account object name (required)
     * @param  string $start_date Start date of the register book / cash report (required)
     * @param  string $end_date End date of the register book / cash report (required)
     * @param  bool $download Specifies if the document is downloaded (optional, default to true)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function reportRegisterBook($check_account_id, $check_account_object_name, $start_date, $end_date, $download = 'true')
    {
        list($response) = $this->reportRegisterBookWithHttpInfo($check_account_id, $check_account_object_name, $start_date, $end_date, $download);
        return $response;
    }

    /**
     * Operation reportRegisterBookWithHttpInfo
     *
     * Export the register book / cash report
     *
     * @param  int $check_account_id Check account you want to export (required)
     * @param  string $check_account_object_name Check account object name (required)
     * @param  string $start_date Start date of the register book / cash report (required)
     * @param  string $end_date End date of the register book / cash report (required)
     * @param  bool $download Specifies if the document is downloaded (optional, default to true)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportRegisterBookWithHttpInfo($check_account_id, $check_account_object_name, $start_date, $end_date, $download = 'true')
    {
        $returnType = '\SplFileObject';
        $request = $this->reportRegisterBookRequest($check_account_id, $check_account_object_name, $start_date, $end_date, $download);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reportRegisterBookAsync
     *
     * Export the register book / cash report
     *
     * @param  int $check_account_id Check account you want to export (required)
     * @param  string $check_account_object_name Check account object name (required)
     * @param  string $start_date Start date of the register book / cash report (required)
     * @param  string $end_date End date of the register book / cash report (required)
     * @param  bool $download Specifies if the document is downloaded (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportRegisterBookAsync($check_account_id, $check_account_object_name, $start_date, $end_date, $download = 'true')
    {
        return $this->reportRegisterBookAsyncWithHttpInfo($check_account_id, $check_account_object_name, $start_date, $end_date, $download)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportRegisterBookAsyncWithHttpInfo
     *
     * Export the register book / cash report
     *
     * @param  int $check_account_id Check account you want to export (required)
     * @param  string $check_account_object_name Check account object name (required)
     * @param  string $start_date Start date of the register book / cash report (required)
     * @param  string $end_date End date of the register book / cash report (required)
     * @param  bool $download Specifies if the document is downloaded (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportRegisterBookAsyncWithHttpInfo($check_account_id, $check_account_object_name, $start_date, $end_date, $download = 'true')
    {
        $returnType = '\SplFileObject';
        $request = $this->reportRegisterBookRequest($check_account_id, $check_account_object_name, $start_date, $end_date, $download);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportRegisterBook'
     *
     * @param  int $check_account_id Check account you want to export (required)
     * @param  string $check_account_object_name Check account object name (required)
     * @param  string $start_date Start date of the register book / cash report (required)
     * @param  string $end_date End date of the register book / cash report (required)
     * @param  bool $download Specifies if the document is downloaded (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reportRegisterBookRequest($check_account_id, $check_account_object_name, $start_date, $end_date, $download = 'true')
    {
        // verify the required parameter 'check_account_id' is set
        if ($check_account_id === null || (is_array($check_account_id) && count($check_account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $check_account_id when calling reportRegisterBook'
            );
        }
        // verify the required parameter 'check_account_object_name' is set
        if ($check_account_object_name === null || (is_array($check_account_object_name) && count($check_account_object_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $check_account_object_name when calling reportRegisterBook'
            );
        }
        // verify the required parameter 'start_date' is set
        if ($start_date === null || (is_array($start_date) && count($start_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $start_date when calling reportRegisterBook'
            );
        }
        // verify the required parameter 'end_date' is set
        if ($end_date === null || (is_array($end_date) && count($end_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $end_date when calling reportRegisterBook'
            );
        }

        $resourcePath = '/Report/registerBook';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($download !== null) {
            $queryParams['download'] = ObjectSerializer::toQueryValue($download);
        }
        // query params
        if ($check_account_id !== null) {
            $queryParams['checkAccount[id]'] = ObjectSerializer::toQueryValue($check_account_id);
        }
        // query params
        if ($check_account_object_name !== null) {
            $queryParams['checkAccount[objectName]'] = ObjectSerializer::toQueryValue($check_account_object_name);
        }
        // query params
        if ($start_date !== null) {
            $queryParams['startDate'] = ObjectSerializer::toQueryValue($start_date);
        }
        // query params
        if ($end_date !== null) {
            $queryParams['endDate'] = ObjectSerializer::toQueryValue($end_date);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/pdf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/pdf'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportVoucherList
     *
     * Export the voucher list
     *
     * @param  string $sev_query_filter_start_date Start date to filter vouchers with (required)
     * @param  string $sev_query_model_name Model name which is exported (required)
     * @param  string $sev_query_object_name SevQuery object name (required)
     * @param  bool $download Specifies if the document is downloaded (optional, default to true)
     * @param  int $sev_query_limit Limit exported vouchers (optional, default to 99999)
     * @param  int $sev_query_offset Set the index where the exported vouchers should start (optional, default to 0)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function reportVoucherList($sev_query_filter_start_date, $sev_query_model_name, $sev_query_object_name, $download = 'true', $sev_query_limit = '99999', $sev_query_offset = '0')
    {
        list($response) = $this->reportVoucherListWithHttpInfo($sev_query_filter_start_date, $sev_query_model_name, $sev_query_object_name, $download, $sev_query_limit, $sev_query_offset);
        return $response;
    }

    /**
     * Operation reportVoucherListWithHttpInfo
     *
     * Export the voucher list
     *
     * @param  string $sev_query_filter_start_date Start date to filter vouchers with (required)
     * @param  string $sev_query_model_name Model name which is exported (required)
     * @param  string $sev_query_object_name SevQuery object name (required)
     * @param  bool $download Specifies if the document is downloaded (optional, default to true)
     * @param  int $sev_query_limit Limit exported vouchers (optional, default to 99999)
     * @param  int $sev_query_offset Set the index where the exported vouchers should start (optional, default to 0)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportVoucherListWithHttpInfo($sev_query_filter_start_date, $sev_query_model_name, $sev_query_object_name, $download = 'true', $sev_query_limit = '99999', $sev_query_offset = '0')
    {
        $returnType = '\SplFileObject';
        $request = $this->reportVoucherListRequest($sev_query_filter_start_date, $sev_query_model_name, $sev_query_object_name, $download, $sev_query_limit, $sev_query_offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reportVoucherListAsync
     *
     * Export the voucher list
     *
     * @param  string $sev_query_filter_start_date Start date to filter vouchers with (required)
     * @param  string $sev_query_model_name Model name which is exported (required)
     * @param  string $sev_query_object_name SevQuery object name (required)
     * @param  bool $download Specifies if the document is downloaded (optional, default to true)
     * @param  int $sev_query_limit Limit exported vouchers (optional, default to 99999)
     * @param  int $sev_query_offset Set the index where the exported vouchers should start (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportVoucherListAsync($sev_query_filter_start_date, $sev_query_model_name, $sev_query_object_name, $download = 'true', $sev_query_limit = '99999', $sev_query_offset = '0')
    {
        return $this->reportVoucherListAsyncWithHttpInfo($sev_query_filter_start_date, $sev_query_model_name, $sev_query_object_name, $download, $sev_query_limit, $sev_query_offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportVoucherListAsyncWithHttpInfo
     *
     * Export the voucher list
     *
     * @param  string $sev_query_filter_start_date Start date to filter vouchers with (required)
     * @param  string $sev_query_model_name Model name which is exported (required)
     * @param  string $sev_query_object_name SevQuery object name (required)
     * @param  bool $download Specifies if the document is downloaded (optional, default to true)
     * @param  int $sev_query_limit Limit exported vouchers (optional, default to 99999)
     * @param  int $sev_query_offset Set the index where the exported vouchers should start (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportVoucherListAsyncWithHttpInfo($sev_query_filter_start_date, $sev_query_model_name, $sev_query_object_name, $download = 'true', $sev_query_limit = '99999', $sev_query_offset = '0')
    {
        $returnType = '\SplFileObject';
        $request = $this->reportVoucherListRequest($sev_query_filter_start_date, $sev_query_model_name, $sev_query_object_name, $download, $sev_query_limit, $sev_query_offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportVoucherList'
     *
     * @param  string $sev_query_filter_start_date Start date to filter vouchers with (required)
     * @param  string $sev_query_model_name Model name which is exported (required)
     * @param  string $sev_query_object_name SevQuery object name (required)
     * @param  bool $download Specifies if the document is downloaded (optional, default to true)
     * @param  int $sev_query_limit Limit exported vouchers (optional, default to 99999)
     * @param  int $sev_query_offset Set the index where the exported vouchers should start (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reportVoucherListRequest($sev_query_filter_start_date, $sev_query_model_name, $sev_query_object_name, $download = 'true', $sev_query_limit = '99999', $sev_query_offset = '0')
    {
        // verify the required parameter 'sev_query_filter_start_date' is set
        if ($sev_query_filter_start_date === null || (is_array($sev_query_filter_start_date) && count($sev_query_filter_start_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sev_query_filter_start_date when calling reportVoucherList'
            );
        }
        // verify the required parameter 'sev_query_model_name' is set
        if ($sev_query_model_name === null || (is_array($sev_query_model_name) && count($sev_query_model_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sev_query_model_name when calling reportVoucherList'
            );
        }
        // verify the required parameter 'sev_query_object_name' is set
        if ($sev_query_object_name === null || (is_array($sev_query_object_name) && count($sev_query_object_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sev_query_object_name when calling reportVoucherList'
            );
        }

        $resourcePath = '/Report/voucherlist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($download !== null) {
            $queryParams['download'] = ObjectSerializer::toQueryValue($download);
        }
        // query params
        if ($sev_query_filter_start_date !== null) {
            $queryParams['sevQuery[filter][startDate]'] = ObjectSerializer::toQueryValue($sev_query_filter_start_date);
        }
        // query params
        if ($sev_query_limit !== null) {
            $queryParams['sevQuery[limit]'] = ObjectSerializer::toQueryValue($sev_query_limit);
        }
        // query params
        if ($sev_query_offset !== null) {
            $queryParams['sevQuery[offset]'] = ObjectSerializer::toQueryValue($sev_query_offset);
        }
        // query params
        if ($sev_query_model_name !== null) {
            $queryParams['sevQuery[modelName]'] = ObjectSerializer::toQueryValue($sev_query_model_name);
        }
        // query params
        if ($sev_query_object_name !== null) {
            $queryParams['sevQuery[objectName]'] = ObjectSerializer::toQueryValue($sev_query_object_name);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/pdf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/pdf'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
